<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zoomable Video Canvas</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }

        #canvasContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
        }

        #videoCanvas,
        #overlayCanvas {
            position: absolute;
            cursor: grab;
        }

        #videoCanvas:active,
        #overlayCanvas:active {
            cursor: grabbing;
        }

        #overlayCanvas {
            pointer-events: none;
            z-index: 10;
        }

        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }

        .debug-layer {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }

        #videoElement {
            display: none;
        }

        #processingCanvas {
            position: absolute;
            pointer-events: none;
            z-index: 101;
            bottom: 0;
            left: 0;

        }

        .control-group {
            margin-bottom: 8px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .gpu-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            color: white;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .gpu-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }

        .gpu-available {
            background-color: #28a745;
        }

        .gpu-unavailable {
            background-color: #dc3545;
        }

        .gpu-unknown {
            background-color: #ffc107;
        }
    </style>
</head>

<body>
    <div class="gpu-indicator" id="gpuIndicator">
        <span class="gpu-status-dot gpu-unknown" id="gpuStatusDot"></span>
        <span id="gpuStatusText">Checking GPU...</span>
    </div>

    <div class="controls">
        <div class="control-group">
            <button id="webcamBtn" class="btn btn-primary btn-sm me-2">Start Webcam</button>
            <button id="autoCalibBtn" class="btn btn-primary btn-sm me-2">Auto-Calibrate</button>
        </div>
        <div class="control-group">
            <select id="cameraSelect" class="form-select form-select-sm d-inline-block me-2" style="width: 200px;">
                <option value="">Select Camera...</option>
            </select>
            <select id="resolutionSelect" class="form-select form-select-sm d-inline-block me-2" style="width: 150px;"
                disabled>
                <option value="">Select Resolution...</option>
            </select>
        </div>
        <div class="control-group">
            <input type="file" id="videoFile" accept="video/*" class="form-control form-control-sm d-inline-block"
                style="width: 200px;">
        </div>
    </div>

    <div id="canvasContainer">
        <canvas id="videoCanvas"></canvas>
        <canvas id="overlayCanvas"></canvas>
        <video id="videoElement" autoplay muted></video>
    </div>
    <!-- <canvas id="processingCanvas" autoplay muted></canvas> -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script src="../ext/ort.min.js"></script>
    <script src="../core/utils/tools.js"></script>
    <script src="../core/utils/icp.js"></script>
    <script src="../core/utils/ransac.js"></script>
    <script src="../core/utils/image.js"></script>
    <script src="../core/Board.js"></script>
    <script src="../core/utils/GPUDetector.js"></script>
    <script src="../core/TargetDetector.js"></script>
    <script src="../ui/ZoomablePannableCanvas.js"></script>
    <script src ="../utils/CameraManager.js"></script>
    <script src="DartNet.js"></script>
    <script>

        // Initialize GPU detector and UI
        const gpuDetector = new GPUDetector();
        const gpuStatusDot = document.getElementById('gpuStatusDot');
        const gpuStatusText = document.getElementById('gpuStatusText');

        // Handle GPU status updates
        gpuDetector.onStatusUpdate((status, details) => {
            switch (status) {
                case 'checking':
                    gpuStatusDot.className = 'gpu-status-dot gpu-unknown';
                    gpuStatusText.textContent = 'Checking GPU...';
                    break;
                case 'webgpu':
                    gpuStatusDot.className = 'gpu-status-dot gpu-available';
                    gpuStatusText.textContent = 'WebGPU';
                    gpuStatusDot.title = details;
                    break;
                case 'webgl':
                    gpuStatusDot.className = 'gpu-status-dot gpu-available';
                    gpuStatusText.textContent = 'WebGL';
                    gpuStatusDot.title = details;
                    break;
                case 'none':
                    gpuStatusDot.className = 'gpu-status-dot gpu-unavailable';
                    gpuStatusText.textContent = 'No GPU';
                    gpuStatusDot.title = details;
                    break;
            }
        });

        // Start GPU detection
        gpuDetector.detectGPU().then(result => {
            console.log('GPU Detection Results:', result);
        });

        // Initialize the canvas with debug overlay
        const zoomableCanvas = new ZoomablePannableCanvas('videoCanvas', 'canvasContainer', 'overlayCanvas');

        // Get DOM elements
        const elements = {
            cameraSelect: document.getElementById("cameraSelect"),
            resolutionSelect: document.getElementById("resolutionSelect"),
            webcamBtn: document.getElementById("webcamBtn"),
            videoElement: document.getElementById("videoElement")
        };

        // Configuration options
        const options = {
            // Basic options
            autoSelectFirstCamera: true,
            defaultResolution: "1920x1080",
            enableOptimalResolution: true,
            progressDelay: 50,
            restartDelay: 100,

            onWebcamReady: (videoElement, resolution) => {
                console.log("Webcam ready with resolution:", resolution);
                if (zoomableCanvas) {
                    zoomableCanvas.setVideoSource(videoElement);
                }
            },

            onError: (error) => {
                console.error("Camera error:", error);
                // Custom error handling
                showErrorNotification(error.message);
            }
        };

        // Initialize CameraManager
        const cameraManager = new CameraManager(elements, options);

        // Video file functionality
        document.getElementById('videoFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const videoElement = document.getElementById('videoElement');
                const url = URL.createObjectURL(file);
                videoElement.src = url;
                videoElement.loop = true;

                videoElement.addEventListener('loadedmetadata', () => {
                    videoElement.play().then(() => {
                        zoomableCanvas.setVideoSource(videoElement);
                        console.log('Video loaded and playing');
                    }).catch(err => {
                        console.error('Error playing video:', err);
                    });
                }, { once: true });

                videoElement.addEventListener('error', (e) => {
                    console.error('Video loading error:', e);
                    alert('Could not load video file');
                });
            }
        });

       
        const dartnet = new DartNet(document.getElementById("videoElement"));

        const autoCalib = async () => {
            console.log("Auto-calib start")
            dartnet.calibrate(onCalibrationSuccess)
        }

        autoCalibBtn.addEventListener('click', autoCalib);


        function recomputeUpTextPos(){
            const upText = PerspectiveUtils.transformPoints([
                [Math.cos(Math.PI * 1.5 + Math.PI / 20) * dartnet.board.r_double * 1.2,
                Math.sin(Math.PI * 1.5 + Math.PI / 20) * dartnet.board.r_double * 1.2]
            ], dartnet.Mi)[0];
            let el = zoomableCanvas.getOverlayElement("20");
            el.x = upText[0];
            el.y = upText[1];
        }

        function onCalibrationSuccess(calibPts) {
            console.log("Calibration succeed:", calibPts)
            for (let i = 0; i < calibPts.length; i++) {
                const p = calibPts[i];
                let el = zoomableCanvas.getOverlayElement(`calib${i}`);
                el.x = p[0];
                el.y = p[1];
            }
            recomputeUpTextPos();
        }

        for (let i = 0; i < 4; i++) {
            // Add interactive elements
            zoomableCanvas.addOverlayElement(`calib${i}`,
                { num: i, x: 100 + i * 20, y: -150, pt_radius: 2, circle_radius: i==0 ? 14 : 10, color: classes_colors[i+1]},
                // Draw callback
                (ctx, element, isSelected) => {
                    ctx.fillStyle = isSelected ? 'rgba(255, 255, 0, 0.7)' : element.color;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.pt_radius / zoomableCanvas.scale, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.strokeStyle = ctx.fillStyle;
                    ctx.lineWidth = (element.num == 0 ? 4 : 2) / zoomableCanvas.scale;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.circle_radius / zoomableCanvas.scale, 0, 2 * Math.PI);
                    ctx.stroke();
                },
                // Hit test callback (optional - defaults to circular)
                (element, worldX, worldY) => {
                    const dx = worldX - element.x;
                    const dy = worldY - element.y;
                    return Math.sqrt(dx * dx + dy * dy) <= element.circle_radius;
                }
            );
        }
        
        // Add "20" Element to help reorient in case it is needed
        zoomableCanvas.addOverlayElement("cropMask",
            {
                net: dartnet, x: 0, y: 0, color: 'rgba(0, 0, 0, 0.6)'
            },
            // Draw callback
            (ctx, element) => {
                const ca = element.net?.cropArea
                if(!ca) return;
                ctx.fillStyle = element.color;
                //ctx.lineWidth = 2 / zoomableCanvas.scale;
                ctx.fillRect(0,0, zoomableCanvas.videoElement.videoWidth, ca[1]);
                ctx.fillRect(0, ca[3], zoomableCanvas.videoElement.videoWidth, zoomableCanvas.videoElement.videoHeight-ca[3]);
                ctx.fillRect(0, ca[1], 0, ca[3]);
                ctx.fillRect(ca[2], ca[1], zoomableCanvas.videoElement.videoWidth-ca[2], ca[3]-ca[1]);

                // ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                // ctx.strokeRect(ca[0], ca[1], ca[2]-ca[0], ca[3]-ca[1]);
            }
        );

        // Add "20" Element to help reorient in case it is needed
        zoomableCanvas.addOverlayElement("20",
            { net:dartnet, x: 0, y:0, radius:30, color: 'rgba(0, 255, 255, 0.5)', compute_possible: () =>{
                return PerspectiveUtils.transformPoints(
                    [...Array(20).keys()].map(i => {
                        const angle = Math.PI * 2 * i / 20 + Math.PI / 20;
                        const dis = dartnet.board.r_double * 1.2
                        return [Math.cos(angle) * dis, Math.sin(angle) * dis];
                    }), dartnet.Mi);
            } },
            // Draw callback
            (ctx, element, isSelected) => {
                ctx.fillStyle = isSelected ? 'rgba(128, 255, 128, 0.7)' : element.color;
                ctx.lineWidth = 2 / zoomableCanvas.scale;
                ctx.beginPath();
                ctx.arc(element.x, element.y, element.radius / zoomableCanvas.scale, 0, 2 * Math.PI);
                ctx.fill();

                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.font = `bold ${40 / zoomableCanvas.scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText("20", element.x, element.y + 14/ zoomableCanvas.scale);

                if(isSelected && element.net?.Mi) {
                    const possible = element.compute_possible()

                    possible.forEach((p) => {
                        ctx.fillStyle = 'rgba(0, 255, 255, 0.25)';
                        ctx.beginPath();
                        ctx.arc(p[0], p[1], 8 / zoomableCanvas.scale, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }
            },
            // Hit test callback (optional - defaults to circular)
            (element, worldX, worldY) => {
                const dx = worldX - element.x;
                const dy = worldY - element.y;
                return Math.sqrt(dx * dx + dy * dy) <= element.radius / zoomableCanvas.scale;
            }
        );

        // Add a virtual target visualizer
        zoomableCanvas.addOverlayElement('virtual_target',
            { net: dartnet, x: 10, y: 200, lineWidth: 2, color: 'rgba(0, 255, 255, 0.5)' },
            // Draw callback
            (ctx, element) => {
                const pts = element.net?.sourceCalibPts;
                const Mi = element.net?.Mi;
                const board = element.net?.board;
                if (!pts || !Mi || !board) return;
                ctx.strokeStyle = element.color;
                ctx.lineWidth = element.lineWidth / zoomableCanvas.scale;

                // Center drawing
                const srcCenter = PerspectiveUtils.transformPoints([[0, 0]], Mi)[0];
                ctx.beginPath();
                ctx.arc(srcCenter[0], srcCenter[1], 1 / zoomableCanvas.scale, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(srcCenter[0], srcCenter[1], 4 / zoomableCanvas.scale, 0, 2 * Math.PI);
                ctx.stroke();

                // Segments drawing
                const boardOuter = board.getOuterPts()
                const srcOuter = PerspectiveUtils.transformPoints(boardOuter, Mi);
                const segStart = PerspectiveUtils.transformPoints(boardOuter.map((p) => {
                    const ratio = board.r_outer_bull / Math.sqrt(p[0] * p[0] + p[1] * p[1]);
                    return [p[0] * ratio, p[1] * ratio];
                }), Mi)
                ctx.beginPath();
                for (let i = 0; i < segStart.length; i++) {
                    ctx.moveTo(segStart[i][0], segStart[i][1]);
                    ctx.lineTo(srcOuter[i][0], srcOuter[i][1]);
                }
                ctx.stroke();


                // Circles drawing    this.r_double = 0.17; //162.0;
                this.r_treble = 0.1064; //107.0;
                this.r_outer_bull = 0.0174; //15.9;
                this.r_inner_bull = 0.007; //6.35;
                this.w_double_treble = 0.01; //8.0;
                const radii = [board.r_inner_bull, board.r_outer_bull, board.r_double - board.w_double_treble,
                board.r_double,
                board.r_treble - board.w_double_treble, board.r_treble
                ]
                
                radii.forEach((r) => {
                    const num = Math.max(Math.ceil(r * 200 * (zoomableCanvas.scale < 1 ? 1 : zoomableCanvas.scale)), 20);
                    const pts = [...Array(num).keys()].map(i => [Math.cos(Math.PI * 2 * i / num) * r, Math.sin(Math.PI * 2 * i / num) * r]);
                    const srcPts = PerspectiveUtils.transformPoints(pts, Mi);
                    ctx.beginPath();
                    ctx.moveTo(srcPts[0], srcPts[1])
                    for (let i = 0; i <= srcPts.length; i++) {
                        p = srcPts[(i + 1) % srcPts.length];
                        ctx.lineTo(p[0], p[1]);
                    }
                    ctx.stroke();
                });
            }
            // ,
            // // Custom virtual target hit test=>scores???
            // (element, worldX, worldY) => {
            //     const halfWidth = element.width / 2;
            //     const halfHeight = element.height / 2;
            //     return worldX >= element.x - halfWidth &&
            //         worldX <= element.x + halfWidth &&
            //         worldY >= element.y - halfHeight &&
            //         worldY <= element.y + halfHeight;
            // }
        );
       
       // Add "20" Element to help reorient in case it is needed
        zoomableCanvas.addOverlayElement("scoreViewer", { x: 0, y: 0, color: 'rgba(0, 255, 128, 0.75)', text:null },
            // Draw callback
            (ctx, element) => {
                if(!element.text) return;
                ctx.fillStyle = element.color;
                ctx.font = `bold ${20 / zoomableCanvas.scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(element.text, element.x, element.y + 14/ zoomableCanvas.scale);
            },
            (element, worldX, worldY) => false // Disable picking drag and drop
        );

        // Set up event callbacks
        zoomableCanvas.setOnElementSelected((id, element) => {
            console.log(`Selected element: ${id}`, element);
        });

        zoomableCanvas.setOnElementDrag((id, element, worldCoords) => {
            console.log(`Dragging ${id} to:`, element.x, element.y);

            if (id.includes("calib")) {
                console.log(`Moving calibration point ${element.num}`)
                if (dartnet.sourceCalibPts) {
                    dartnet.sourceCalibPts[element.num] = [element.x, element.y];
                    dartnet.updateCalibPoints(dartnet.sourceCalibPts);
                }
            }
            else if (id == "20") {
                const possible = element.compute_possible();
                const distances = possible.map((p) => MathUtils.distance(p, [element.x, element.y]))
                var indexMin = distances.indexOf(Math.min(...distances));
                var rotMatrix = MathUtils.createRotationMatrix(((indexMin+5)%30) *360/20);
                var boardRotated = MathUtils.rotatePoints(dartnet.board.board_cal_pts,rotMatrix);
                var newCalib = PerspectiveUtils.transformPoints(boardRotated, dartnet.Mi)
                dartnet.updateCalibPoints(newCalib);
                onCalibrationSuccess(newCalib);
            }
        });

        zoomableCanvas.setOnElementDragEnd((id, element, worldCoords) => {
            console.log(`Finished dragging ${id}`);
        });


        document.getElementById("videoCanvas").addEventListener('mousemove', (event) => {
            //console.log('mousemove:',event)
            //const worldP = [event.clientX,event.clientY];
            const srcP = zoomableCanvas.canvasToWorld(event.clientX,event.clientY);
            //const score = dartnet.targetDetector.getDartScores([srcP])[0];
            // TODO: use detector's one
            const score = dartnet.sourceCalibPts ? dartnet.board.getDartScores(dartnet.sourceCalibPts, [[srcP.x, srcP.y]]) [0] : null;
            let element = zoomableCanvas.getOverlayElement("scoreViewer");
            element.x = srcP.x + 40 / zoomableCanvas.scale;
            element.y = srcP.y;
            element.text = score;
        });
    </script>
</body>

</html>