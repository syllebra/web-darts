<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zoomable Video Canvas</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }

        #canvasContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
        }

        #videoCanvas,
        #overlayCanvas {
            position: absolute;
            cursor: grab;
        }

        #videoCanvas:active,
        #overlayCanvas:active {
            cursor: grabbing;
        }

        #overlayCanvas {
            pointer-events: none;
            z-index: 10;
        }

        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }

        .debug-layer {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }

        #videoElement {
            display: none;
        }

        #processingCanvas {
            position: absolute;
            pointer-events: none;
            z-index: 101;
            bottom: 0;
            left: 0;

        }

        .control-group {
            margin-bottom: 8px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .status-indicators {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-indicator {
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            color: white;
            display: flex;
            align-items: center;
            gap: 5px;
            min-width: 120px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            flex-shrink: 0;
        }

        .gpu-available {
            background-color: #28a745;
        }

        .gpu-unavailable {
            background-color: #dc3545;
        }

        .gpu-unknown {
            background-color: #ffc107;
        }

        /* Dart detection status colors */
        .dart-initializing {
            background-color: #FFA500;
        }

        .dart-detecting {
            background-color: #28a745;
        }

        .dart-paused {
            background-color: #ffc107;
        }

        .dart-detected {
            background-color: #dc3545;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .dart-unknown {
            background-color: #6c757d;
        }

        /* Status text styling */
        .status-text {
            font-weight: 500;
            flex-grow: 1;
        }

        #debugCanvas {
            pointer-events: none;
            z-index: 100;
            position: absolute;
            left : 0;
            bottom: 0;
            width: 640px;
            height: 640px;
        }        
    </style>
</head>

<body>
    <div class="status-indicators">
        <div class="status-indicator" id="gpuIndicator">
            <span class="status-dot gpu-unknown" id="gpuStatusDot"></span>
            <span class="status-text" id="gpuStatusText">Checking GPU...</span>
        </div>
        
        <div class="status-indicator" id="dartDetectionIndicator">
            <span class="status-dot dart-unknown" id="dartStatusDot"></span>
            <span class="status-text" id="dartStatusText">Not Started</span>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <button id="webcamBtn" class="btn btn-primary btn-sm me-2">Start Webcam</button>
            <button id="autoCalibBtn" class="btn btn-primary btn-sm me-2">Auto-Calibrate</button>
            <button id="startDetectionBtn" class="btn btn-success btn-sm me-2">Start Detection</button>
            <button id="stopDetectionBtn" class="btn btn-danger btn-sm me-2" disabled>Stop Detection</button>
        </div>
        <div class="control-group">
            <select id="cameraSelect" class="form-select form-select-sm d-inline-block me-2" style="width: 200px;">
                <option value="">Select Camera...</option>
            </select>
            <select id="resolutionSelect" class="form-select form-select-sm d-inline-block me-2" style="width: 150px;"
                disabled>
                <option value="">Select Resolution...</option>
            </select>
        </div>
        <div class="control-group">
            <input type="file" id="videoFile" accept="video/*" class="form-control form-control-sm d-inline-block"
                style="width: 200px;">
        </div>
    </div>

    <div id="canvasContainer">
        <canvas id="videoCanvas"></canvas>
        <canvas id="overlayCanvas"></canvas>
        <video id="videoElement" autoplay muted></video>
    </div>
    <canvas id="debugCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script src="../ext/ort.min.js"></script>
    <script src="../core/utils/tools.js"></script>
    <script src="../core/utils/icp.js"></script>
    <script src="../core/utils/ransac.js"></script>
    <script src="../core/utils/image.js"></script>
    <script src="../core/Board.js"></script>
    <script src="../core/utils/GPUDetector.js"></script>
    <script src="../core/utils/yolo.js"></script>
    <script src="../core/TargetDetector.js"></script>
    <script src="../core/DartDetector.js"  type="text/javascript"></script>
    <script src="../ui/ZoomablePannableCanvas.js"></script>
    <script src="../utils/CameraManager.js"></script>
    <script src="DartNet.js"></script>
    <script>

        // Init main class instance
        const dartnet = new DartNet(document.getElementById("videoElement"));

        // Initialize GPU detector UI
        const gpuStatusDot = document.getElementById('gpuStatusDot');
        const gpuStatusText = document.getElementById('gpuStatusText');

        // Handle GPU status updates
        gpuDetector.onStatusUpdate((status, details) => {
            switch (status) {
                case 'checking':
                    gpuStatusDot.className = 'status-dot gpu-unknown';
                    gpuStatusText.textContent = 'Checking GPU...';
                    break;
                case 'webgpu':
                    gpuStatusDot.className = 'status-dot gpu-available';
                    gpuStatusText.textContent = 'WebGPU';
                    gpuStatusDot.title = details;
                    break;
                case 'webgl':
                    gpuStatusDot.className = 'status-dot gpu-available';
                    gpuStatusText.textContent = 'WebGL';
                    gpuStatusDot.title = details;
                    break;
                case 'none':
                    gpuStatusDot.className = 'status-dot gpu-unavailable';
                    gpuStatusText.textContent = 'No GPU';
                    gpuStatusDot.title = details;
                    break;
            }

            if(status != 'checking' && !dartnet.dartDetector) {
                dartnet.initDetectors();
                dartnet.dartDetector.onDetectionCallbacks.push((data) => {
                    console.log("DartImpact:", data);
                    zoomableCanvas.getOverlayElement("dartImpactDebug").setDetected(data.delta, dartnet.dartDetector.modelSize, dartnet.dartDetector.modelSize);

                    const debugCanvas = document.getElementById("debugCanvas");
                    debugCanvas.width = 640;
                    debugCanvas.height = 640;
                    
                    const debugCtx = debugCanvas.getContext("2d");
                    debugCtx.putImageData( ImageProcessor.grayscaleToImageData(data.delta),0,0);
                    debugCtx.strokeStyle= "rgba(255, 255, 0, 1.0)";
                    data.boxes.forEach((b) => {
                        debugCtx.strokeRect(b[0],b[1],b[2]-b[0], b[3]-b[1]);
                    });                    

                    //const tipEl = zoomableCanvas.getOverlayElement("dartTip");
                    //tipEl.x = 
                    const dartDbg = zoomableCanvas.getOverlayElement("dartDebug");
                    dartDbg.boxes = data.boxes.map((b) => {
                        let tl = dartnet.cropppedToSource([b[0],b[1]]);
                        let br = dartnet.cropppedToSource([b[2],b[3]]);
                        return [tl[0],tl[1],br[0],br[1],b[4],b[5]];
                    });
                    console.log(dartDbg)
                });
                // Set up status change callback
                dartnet.dartDetector.addStatusChangeCallback((newStatus, oldStatus) => {
                    console.log(`Dart detection status changed: ${oldStatus} â†’ ${newStatus}`);
                    updateDartDetectionStatus(newStatus);
                });
            }
        });


        // Dart Detection Status Management
        const dartStatusDot = document.getElementById('dartStatusDot');
        const dartStatusText = document.getElementById('dartStatusText');
        const startDetectionBtn = document.getElementById('startDetectionBtn');
        const stopDetectionBtn = document.getElementById('stopDetectionBtn');

        // Dart detection status handler
        function updateDartDetectionStatus(status, statusName) {
            // Remove all status classes
            dartStatusDot.className = 'status-dot';
            
            switch (status) {
                case DartDetectorStatus.INITIALIZING:
                    dartStatusDot.classList.add('dart-initializing');
                    dartStatusText.textContent = 'âš™ï¸ Initializing...';
                    startDetectionBtn.disabled = true;
                    stopDetectionBtn.disabled = false;
                    break;
                case DartDetectorStatus.DETECTING:
                    dartStatusDot.classList.add('dart-detecting');
                    dartStatusText.textContent = 'ðŸ” Detecting';
                    startDetectionBtn.disabled = true;
                    stopDetectionBtn.disabled = false;
                    break;
                case DartDetectorStatus.PAUSE:
                    dartStatusDot.classList.add('dart-paused');
                    dartStatusText.textContent = 'â¸ï¸ Paused';
                    startDetectionBtn.disabled = false;
                    stopDetectionBtn.disabled = true;
                    break;
                case DartDetectorStatus.DETECTED:
                    dartStatusDot.classList.add('dart-detected');
                    dartStatusText.textContent = 'ðŸŽ¯ Impact Detected!';
                    // Keep buttons as they are during detection
                    break;
                default:
                    dartStatusDot.classList.add('dart-unknown');
                    dartStatusText.textContent = 'Not Started';
                    startDetectionBtn.disabled = false;
                    stopDetectionBtn.disabled = true;
                    break;
            }
        }

        // Initialize with default status
        updateDartDetectionStatus(-1, 'Not Started');

        // Initialize the canvas with debug overlay
        const zoomableCanvas = new ZoomablePannableCanvas('videoCanvas', 'canvasContainer', 'overlayCanvas');

        // Get DOM elements for camera manager
        const elements = {
            cameraSelect: document.getElementById("cameraSelect"),
            resolutionSelect: document.getElementById("resolutionSelect"),
            webcamBtn: document.getElementById("webcamBtn"),
            videoElement: document.getElementById("videoElement")
        };

        // Configuration options
        const options = {
            // Basic options
            autoSelectFirstCamera: true,
            defaultResolution: "1920x1080",
            enableOptimalResolution: true,
            progressDelay: 50,
            restartDelay: 100,

            onWebcamReady: (videoElement, resolution) => {
                console.log("Webcam ready with resolution:", resolution);
                if (zoomableCanvas) {
                    zoomableCanvas.setVideoSource(videoElement);
                }
            },

            onError: (error) => {
                console.error("Camera error:", error);
                // Custom error handling
                showErrorNotification(error.message);
            }
        };

        // Initialize CameraManager
        const cameraManager = new CameraManager(elements, options);

        // Video file functionality
        document.getElementById('videoFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const videoElement = document.getElementById('videoElement');
                const url = URL.createObjectURL(file);
                videoElement.src = url;
                videoElement.loop = true;

                videoElement.addEventListener('loadedmetadata', () => {
                    videoElement.play().then(() => {
                        zoomableCanvas.setVideoSource(videoElement);
                        console.log('Video loaded and playing');
                    }).catch(err => {
                        console.error('Error playing video:', err);
                    });
                }, { once: true });

                videoElement.addEventListener('error', (e) => {
                    console.error('Video loading error:', e);
                    alert('Could not load video file');
                });
            }
        });


        // Detection control buttons
        startDetectionBtn.addEventListener('click', () => {
            if (dartnet.dartDetector) {
                dartnet.dartDetector.start();
            }
        });

        stopDetectionBtn.addEventListener('click', () => {
            if (dartnet.dartDetector) {
                dartnet.dartDetector.stop();
            }
        });

        let animationId=null;
       async function processFrame() {
            let wait = false;
            if (dartnet.dartDetector && dartnet.dartDetector.currentStatus != DartDetectorStatus.DETECTING && dartnet.dartDetector.currentStatus != DartDetectorStatus.DETECTED) wait=true;
            if (!dartnet.videoSource || dartnet.dartDetector?.pauseDetection || dartnet.videoSource.readyState !== dartnet.videoSource.HAVE_ENOUGH_DATA) wait=true;
            if(!wait) {
                try {
                    dartnet.detectDartImpact();
                } catch (err) {
                    console.error('Error processing frame:', err);
                }
            }
            animationId = requestAnimationFrame(processFrame);
        }
        processFrame();

        const autoCalib = async () => {
            console.log("Auto-calib start")
            dartnet.calibrate(onCalibrationSuccess)
        }

        autoCalibBtn.addEventListener('click', autoCalib);

        function recomputeUpTextPos(){
            const upText = PerspectiveUtils.transformPoints([
                [Math.cos(Math.PI * 1.5 + Math.PI / 20) * dartnet.board.r_double * 1.2,
                Math.sin(Math.PI * 1.5 + Math.PI / 20) * dartnet.board.r_double * 1.2]
            ], dartnet.Mi)[0];
            let el = zoomableCanvas.getOverlayElement("20");
            el.x = upText[0];
            el.y = upText[1];
        }

        function onCalibrationSuccess(calibPts) {
            console.log("Calibration succeed:", calibPts)
            for (let i = 0; i < calibPts.length; i++) {
                const p = calibPts[i];
                let el = zoomableCanvas.getOverlayElement(`calib${i}`);
                el.x = p[0];
                el.y = p[1];
            }
            recomputeUpTextPos();
        }

        for (let i = 0; i < 4; i++) {
            // Add interactive elements
            zoomableCanvas.addOverlayElement(`calib${i}`,
                { num: i, x: 100 + i * 20, y: -150, pt_radius: 2, circle_radius: i==0 ? 14 : 10, color: classes_colors[i+1]},
                // Draw callback
                (ctx, element, isSelected) => {
                    ctx.fillStyle = isSelected ? 'rgba(255, 255, 0, 0.7)' : element.color;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.pt_radius / zoomableCanvas.scale, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.strokeStyle = ctx.fillStyle;
                    ctx.lineWidth = (element.num == 0 ? 4 : 2) / zoomableCanvas.scale;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.circle_radius / zoomableCanvas.scale, 0, 2 * Math.PI);
                    ctx.stroke();
                },
                // Hit test callback (optional - defaults to circular)
                (element, worldX, worldY) => {
                    const dx = worldX - element.x;
                    const dy = worldY - element.y;
                    return Math.sqrt(dx * dx + dy * dy) <= element.circle_radius;
                }
            );
        }
        
        // Add "20" Element to help reorient in case it is needed
        zoomableCanvas.addOverlayElement("cropMask",
            {
                net: dartnet, x: 0, y: 0, color: 'rgba(0, 0, 0, 0.6)'
            },
            // Draw callback
            (ctx, element) => {
                const ca = element.net?.cropArea
                if(!ca) return;
                ctx.fillStyle = element.color;
                //ctx.lineWidth = 2 / zoomableCanvas.scale;
                ctx.fillRect(0,0, zoomableCanvas.videoElement.videoWidth, ca[1]);
                ctx.fillRect(0, ca[3], zoomableCanvas.videoElement.videoWidth, zoomableCanvas.videoElement.videoHeight-ca[3]);
                ctx.fillRect(0, ca[1], 0, ca[3]);
                ctx.fillRect(ca[2], ca[1], zoomableCanvas.videoElement.videoWidth-ca[2], ca[3]-ca[1]);

                // ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                // ctx.strokeRect(ca[0], ca[1], ca[2]-ca[0], ca[3]-ca[1]);
            }
        );

        // Add "20" Element to help reorient in case it is needed
        zoomableCanvas.addOverlayElement("20",
            { net:dartnet, x: 0, y:0, radius:30, color: 'rgba(0, 255, 255, 0.5)', compute_possible: () =>{
                return PerspectiveUtils.transformPoints(
                    [...Array(20).keys()].map(i => {
                        const angle = Math.PI * 2 * i / 20 + Math.PI / 20;
                        const dis = dartnet.board.r_double * 1.2
                        return [Math.cos(angle) * dis, Math.sin(angle) * dis];
                    }), dartnet.Mi);
            } },
            // Draw callback
            (ctx, element, isSelected) => {
                ctx.fillStyle = isSelected ? 'rgba(128, 255, 128, 0.7)' : element.color;
                ctx.lineWidth = 2 / zoomableCanvas.scale;
                ctx.beginPath();
                ctx.arc(element.x, element.y, element.radius / zoomableCanvas.scale, 0, 2 * Math.PI);
                ctx.fill();

                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.font = `bold ${40 / zoomableCanvas.scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText("20", element.x, element.y + 14/ zoomableCanvas.scale);

                if(isSelected && element.net?.Mi) {
                    const possible = element.compute_possible()

                    possible.forEach((p) => {
                        ctx.fillStyle = 'rgba(0, 255, 255, 0.25)';
                        ctx.beginPath();
                        ctx.arc(p[0], p[1], 8 / zoomableCanvas.scale, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }
            },
            // Hit test callback (optional - defaults to circular)
            (element, worldX, worldY) => {
                const dx = worldX - element.x;
                const dy = worldY - element.y;
                return Math.sqrt(dx * dx + dy * dy) <= element.radius / zoomableCanvas.scale;
            }
        );

        // Add a virtual target visualizer
        zoomableCanvas.addOverlayElement('virtual_target',
            { net: dartnet, x: 10, y: 200, lineWidth: 2, color: 'rgba(0, 255, 255, 0.5)' },
            // Draw callback
            (ctx, element) => {
                const pts = element.net?.sourceCalibPts;
                const Mi = element.net?.Mi;
                const board = element.net?.board;
                if (!pts || !Mi || !board) return;
                ctx.strokeStyle = element.color;
                ctx.lineWidth = element.lineWidth / zoomableCanvas.scale;

                // Center drawing
                const srcCenter = PerspectiveUtils.transformPoints([[0, 0]], Mi)[0];
                ctx.beginPath();
                ctx.arc(srcCenter[0], srcCenter[1], 1 / zoomableCanvas.scale, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(srcCenter[0], srcCenter[1], 4 / zoomableCanvas.scale, 0, 2 * Math.PI);
                ctx.stroke();

                // Segments drawing
                const boardOuter = board.getOuterPts()
                const srcOuter = PerspectiveUtils.transformPoints(boardOuter, Mi);
                const segStart = PerspectiveUtils.transformPoints(boardOuter.map((p) => {
                    const ratio = board.r_outer_bull / Math.sqrt(p[0] * p[0] + p[1] * p[1]);
                    return [p[0] * ratio, p[1] * ratio];
                }), Mi)
                ctx.beginPath();
                for (let i = 0; i < segStart.length; i++) {
                    ctx.moveTo(segStart[i][0], segStart[i][1]);
                    ctx.lineTo(srcOuter[i][0], srcOuter[i][1]);
                }
                ctx.stroke();

                // Circles drawing
                const radii = [board.r_inner_bull, board.r_outer_bull, board.r_double - board.w_double_treble,
                board.r_double,
                board.r_treble - board.w_double_treble, board.r_treble
                ]
                
                radii.forEach((r) => {
                    const num = Math.max(Math.ceil(r * 200 * (zoomableCanvas.scale < 1 ? 1 : zoomableCanvas.scale)), 20);
                    const pts = [...Array(num).keys()].map(i => [Math.cos(Math.PI * 2 * i / num) * r, Math.sin(Math.PI * 2 * i / num) * r]);
                    const srcPts = PerspectiveUtils.transformPoints(pts, Mi);
                    ctx.beginPath();
                    ctx.moveTo(srcPts[0], srcPts[1])
                    for (let i = 0; i <= srcPts.length; i++) {
                        p = srcPts[(i + 1) % srcPts.length];
                        ctx.lineTo(p[0], p[1]);
                    }
                    ctx.stroke();
                });
            }
        );
       
       // Add score viewer on mouse hover
        zoomableCanvas.addOverlayElement("scoreViewer", { x: 0, y: 0, color: 'rgba(0, 255, 128, 0.75)', text:null },
            // Draw callback
            (ctx, element) => {
                if(!element.text) return;
                ctx.fillStyle = element.color;
                ctx.font = `bold ${20 / zoomableCanvas.scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(element.text, element.x, element.y + 14/ zoomableCanvas.scale);
            },
            (element, worldX, worldY) => false // Disable picking drag and drop
        );

        // Add Dart tip debug viewer
        zoomableCanvas.addOverlayElement("dartTip", { x: 40, y: 0, pt_radius: 1.5, radius: 10, color: 'rgba(0, 128, 255, 0.5)'},
            // Draw callback
            (ctx, element) => {
                //if(!element.text) return;
                ctx.fillStyle = element.color;
                ctx.beginPath();
                ctx.arc(element.x, element.y, element.pt_radius / zoomableCanvas.scale, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = element.color;
                ctx.lineWidth = 1 / zoomableCanvas.scale;
                ctx.beginPath();
                let  dec = element.radius / zoomableCanvas.scale;
                ctx.moveTo(element.x-dec, element.y-dec);
                ctx.lineTo(element.x+dec, element.y+dec);
                ctx.moveTo(element.x+dec, element.y-dec);
                ctx.lineTo(element.x-dec, element.y+dec);
                ctx.stroke();

                // ctx.font = `bold ${20 / zoomableCanvas.scale}px Arial`;
                // ctx.textAlign = 'center';
                // ctx.fillText(element.text, element.x, element.y + 14/ zoomableCanvas.scale);
            },
            (element, worldX, worldY) => false // Disable picking drag and drop
        );

                // Add Dart tip debug viewer
        zoomableCanvas.addOverlayElement("dartDebug", { x: 0, y: 0, boxes: null},
            // Draw callback
            (ctx, element) => {
                if(!element.boxes) return;
                element.boxes.forEach((b) => {
                ctx.strokeStyle = classes_colors[b[4]];
                ctx.lineWidth = 1.5 / zoomableCanvas.scale;
                ctx.strokeRect(b[0],b[1],b[2]-b[0],b[3]-b[1]);

                });

                // ctx.font = `bold ${20 / zoomableCanvas.scale}px Arial`;
                // ctx.textAlign = 'center';
                // ctx.fillText(element.text, element.x, element.y + 14/ zoomableCanvas.scale);
            },
            (element, worldX, worldY) => false // Disable picking drag and drop
        );


       // Add "20" Element to help reorient in case it is needed
        zoomableCanvas.addOverlayElement("scoreViewer", { x: 0, y: 0, color: 'rgba(0, 255, 128, 0.75)', text:null },
            // Draw callback
            (ctx, element) => {
                if(!element.text) return;
                ctx.fillStyle = element.color;
                ctx.font = `bold ${20 / zoomableCanvas.scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(element.text, element.x, element.y + 14/ zoomableCanvas.scale);
            },
            (element, worldX, worldY) => false // Disable picking drag and drop
        );



        // Add "20" Element to help reorient in case it is needed
        zoomableCanvas.addOverlayElement("dartImpactDebug",
            {
                img: null, net:dartnet, x: 0, y: 0, color: [255,0,0,0.8], setDetected(grayImg, width, height) {
                    const imageData = new ImageData(width, height);
                    const data = imageData.data;

                    for (let i = 0; i < grayImg.data.length; i++) {
                    const value = grayImg.data[i];
                    data[i * 4] = Math.floor(value * this.color[0] / 255); // R
                    data[i * 4 + 1] = Math.floor(value * this.color[1] / 255); // G
                    data[i * 4 + 2] = Math.floor(value * this.color[2] / 255); // B
                    data[i * 4 + 3] = Math.floor(this.color[3] * 255); // A
                    }
                    this.img = ImageProcessor.imageDataToImage(imageData);
                }
            },
            // Draw callback
            (ctx, element) => {
                const ca = element.net?.cropArea
                if(!ca || !element.img) return;
                
                ctx.drawImage(element.img, ca[0],ca[1],ca[2]-ca[0],ca[3]-ca[1]);
            }
        );

        // Set up event callbacks
        zoomableCanvas.setOnElementSelected((id, element) => {
            console.log(`Selected element: ${id}`, element);
        });

        zoomableCanvas.setOnElementDrag((id, element, worldCoords) => {
            console.log(`Dragging ${id} to:`, element.x, element.y);

            if (id.includes("calib")) {
                console.log(`Moving calibration point ${element.num}`)
                if (dartnet.sourceCalibPts) {
                    dartnet.sourceCalibPts[element.num] = [element.x, element.y];
                    dartnet.updateCalibPoints(dartnet.sourceCalibPts);
                }
            }
            else if (id == "20") {
                const possible = element.compute_possible();
                const distances = possible.map((p) => MathUtils.distance(p, [element.x, element.y]))
                var indexMin = distances.indexOf(Math.min(...distances));
                var rotMatrix = MathUtils.createRotationMatrix(((indexMin+5)%30) *360/20);
                var boardRotated = MathUtils.rotatePoints(dartnet.board.board_cal_pts,rotMatrix);
                var newCalib = PerspectiveUtils.transformPoints(boardRotated, dartnet.Mi)
                dartnet.updateCalibPoints(newCalib);
                onCalibrationSuccess(newCalib);
            }
        });

        zoomableCanvas.setOnElementDragEnd((id, element, worldCoords) => {
            console.log(`Finished dragging ${id}`);
        });

        document.getElementById("videoCanvas").addEventListener('mousemove', (event) => {
            const srcP = zoomableCanvas.canvasToWorld(event.clientX,event.clientY);
            const score = dartnet.sourceCalibPts ? dartnet.board.getDartScores(dartnet.sourceCalibPts, [[srcP.x, srcP.y]]) [0] : null;
            let element = zoomableCanvas.getOverlayElement("scoreViewer");
            element.x = srcP.x + 40 / zoomableCanvas.scale;
            element.y = srcP.y;
            element.text = score;
        });

    </script>
</body>

</html>
