<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zoomable Video Canvas</title>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }

        #canvasContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
        }

        #videoCanvas,
        #overlayCanvas {
            position: absolute;
            cursor: grab;
        }

        #videoCanvas:active,
        #overlayCanvas:active {
            cursor: grabbing;
        }

        #overlayCanvas {
            pointer-events: none;
            z-index: 10;
        }

        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
        }

        .debug-layer {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }

        #videoElement {
            display: none;
        }

        #processingCanvas {
            position: absolute;
            pointer-events: none;
            z-index: 101;
            bottom: 0;
            left: 0;

        }

        .control-group {
            margin-bottom: 8px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .status-indicators {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-indicator {
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            color: white;
            display: flex;
            align-items: center;
            gap: 5px;
            min-width: 120px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            flex-shrink: 0;
        }

        .gpu-available {
            background-color: #28a745;
        }

        .gpu-unavailable {
            background-color: #dc3545;
        }

        .gpu-unknown {
            background-color: #ffc107;
        }

        /* Dart detection status colors */
        .dart-initializing {
            background-color: #FFA500;
        }

        .dart-detecting {
            background-color: #28a745;
        }

        .dart-paused {
            background-color: #ffc107;
        }

        .dart-detected {
            background-color: #dc3545;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .dart-unknown {
            background-color: #6c757d;
        }

        /* Status text styling */
        .status-text {
            font-weight: 500;
            flex-grow: 1;
        }

        /* Loading spinner styles */
        .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001;
            color: white;
            animation: spin 1s linear infinite;
            font-size: 1.2rem;
        }

        .btn-loading {
            position: relative;
            overflow: hidden;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .btn-loading {
            position: relative;
        }

        #debugCanvas {
            pointer-events: none;
            z-index: 100;
            position: absolute;
            left: 0;
            bottom: 0;
            width: 640px;
            height: 640px;
        }
    </style>
</head>

<body>
    <div class="status-indicators">
        <div class="status-indicator" id="gpuIndicator">
            <span class="status-dot gpu-unknown" id="gpuStatusDot"></span>
            <span class="status-text" id="gpuStatusText">Checking GPU...</span>
        </div>

        <div class="status-indicator" id="dartDetectionIndicator">
            <span class="status-dot dart-unknown" id="dartStatusDot"></span>
            <span class="status-text" id="dartStatusText">Not Started</span>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <div class="btn-group me-3" role="group">
                <button id="cameraSelectBtn" class="btn" disabled title="Select Camera"
                    style="font-size: 1.2rem; padding: 0.5rem 1rem; background-color: #f0f0f0; border: 1px solid #ccc;">
                    <i class="fas fa-camera fa-spinner loading-spinner"></i>
                </button>

                <button id="webcamPlayBtn" class="btn" title="Start Webcam" style="font-size: 1.2rem; padding: 0.5rem 1rem; background-color: #f0f0f0; border: 1px solid #ccc;">
                    <i class="fas fa-play"></i>
                </button>
                <button id="webcamStopBtn" class="btn" disabled title="Stop Webcam" style="font-size: 1.2rem; padding: 0.5rem 1rem; background-color: #f0f0f0; border: 1px solid #ccc;">
                    <i class="fas fa-stop"></i>
                </button>
            </div>
        </div>
        <div class="control-group">
            <div class="btn-group me-3" role="group">
                <button id="videoFileSelectBtn" class="btn" title="Select Video File"
                    style="font-size: 1.2rem; padding: 0.5rem 1rem; background-color: #f0f0f0; border: 1px solid #ccc;">
                    <i class="fas fa-video"></i>
                </button>
                <button id="videoFilePlayBtn" class="btn" disabled title="Play Video File" style="font-size: 1.2rem; padding: 0.5rem 1rem; background-color: #f0f0f0; border: 1px solid #ccc;">
                    <i class="fas fa-play"></i>
                </button>
                <button id="videoFilePauseBtn" class="btn" disabled title="Pause Video File" style="font-size: 1.2rem; padding: 0.5rem 1rem; background-color: #f0f0f0; border: 1px solid #ccc;">
                    <i class="fas fa-pause"></i>
                </button>
                <button id="videoFileStopBtn" class="btn" disabled title="Stop Video File" style="font-size: 1.2rem; padding: 0.5rem 1rem; background-color: #f0f0f0; border: 1px solid #ccc;">
                    <i class="fas fa-stop"></i>
                </button>
            </div>
            <input type="file" id="videoFile" accept="video/*" style="display: none;">
        </div>
        <div class="control-group">
            <button id="autoCalibBtn" class="btn" title="Auto-Calibrate" style="font-size: 1.2rem; padding: 0.5rem 1rem; background-color: #f0f0f0; border: 1px solid #ccc;">
                <i class="fas fa-bullseye"></i> Auto-Calibrate
            </button>
        </div>
        <div class="control-group">
            <button id="toggleDetectionBtn" class="btn" title="Toggle Dart Detection" style="font-size: 1.2rem; padding: 0.5rem 1rem; background-color: #f0f0f0; border: 1px solid #ccc;">
                <i class="fas fa-eye"></i>
            </button>
        </div>
    </div>

    <!-- Camera Selection Modal -->
    <div class="modal fade" id="cameraModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-fullscreen">
            <div class="modal-content bg-dark text-white">
                <div class="modal-header border-0">
                    <h5 class="modal-title">Select Camera</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="cameraList" class="d-flex flex-wrap gap-3 justify-content-center align-items-center h-100">
                        <!-- Camera options will be populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="canvasContainer">
        <canvas id="videoCanvas"></canvas>
        <canvas id="overlayCanvas"></canvas>
        <video id="videoElement" autoplay muted controls width="1920" height="1080"></video>
    </div>
    <!-- <canvas id="debugCanvas"></canvas> -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script src="../ext/ort.min.js"></script>
    <script src="../core/utils/tools.js"></script>
    <script src="../core/utils/icp.js"></script>
    <script src="../core/utils/ransac.js"></script>
    <script src="../core/utils/image.js"></script>
    <script src="../core/Board.js"></script>
    <script src="../core/utils/GPUDetector.js"></script>
    <script src="../core/utils/yolo.js"></script>
    <script src="../core/TargetDetector.js"></script>
    <script src="../core/DartDetector.js" type="text/javascript"></script>
    <script src="../ui/ZoomablePannableCanvas.js"></script>
    <script src="../utils/CameraManager.js"></script>
    <script src="../utils/sound.js"></script>
    <script src="DartNet.js"></script>

    <script>eruda.init();</script>
    <script>

        // Init main class instance

        const videoElement = document.getElementById("videoElement");
        // videoElement.addEventListener('loadedmetadata', () => {
        //     console.log("AUTO-ZOOM:",videoElement.videoWidth, videoElement.videoHeight)
        //     });


        const dartnet = new DartNet(videoElement);

        // Initialize GPU detector UI
        const gpuStatusDot = document.getElementById('gpuStatusDot');
        const gpuStatusText = document.getElementById('gpuStatusText');

        // Handle GPU status updates
        gpuDetector.onStatusUpdate((status, details) => {
            switch (status) {
                case 'checking':
                    gpuStatusDot.className = 'status-dot gpu-unknown';
                    gpuStatusText.textContent = 'Checking GPU...';
                    break;
                case 'webgpu':
                    gpuStatusDot.className = 'status-dot gpu-available';
                    gpuStatusText.textContent = 'WebGPU';
                    gpuStatusDot.title = details;
                    break;
                case 'webgl':
                    gpuStatusDot.className = 'status-dot gpu-available';
                    gpuStatusText.textContent = 'WebGL';
                    gpuStatusDot.title = details;
                    break;
                case 'none':
                    gpuStatusDot.className = 'status-dot gpu-unavailable';
                    gpuStatusText.textContent = 'No GPU';
                    gpuStatusDot.title = details;
                    break;
            }

            if (status != 'checking' && !dartnet.dartDetector) {
                dartnet.initDetectors();
                dartnet.dartDetector.onDetectionCallbacks.push(onDartDetected);
                // Set up status change callback
                dartnet.dartDetector.addStatusChangeCallback((newStatus, oldStatus) => {
                    //console.log(`Dart detection status changed: ${oldStatus} â†’ ${newStatus}`);
                    updateDartDetectionStatus(newStatus);
                });
            }
        });


        // Dart Detection Status Management
        const dartStatusDot = document.getElementById('dartStatusDot');
        const dartStatusText = document.getElementById('dartStatusText');

        // Dart detection status handler
        function updateDartDetectionStatus(status, statusName) {
            // Remove all status classes
            dartStatusDot.className = 'status-dot';
            const toggleBtn = document.getElementById('toggleDetectionBtn');
            const icon = toggleBtn.querySelector('i');

            switch (status) {
                case DartDetectorStatus.INITIALIZING:
                    dartStatusDot.classList.add('dart-initializing');
                    dartStatusText.textContent = 'âš™ï¸ Initializing...';
                    toggleBtn.disabled = true;
                    break;
                case DartDetectorStatus.DETECTING:
                    dartStatusDot.classList.add('dart-detecting');
                    dartStatusText.textContent = 'ðŸ” Detecting';
                    icon.className = 'fas fa-arrows-to-dot';
                    toggleBtn.title = 'Stop Dart Detection';
                    toggleBtn.disabled = false;
                    break;
                case DartDetectorStatus.PAUSE:
                    dartStatusDot.classList.add('dart-paused');
                    dartStatusText.textContent = 'â¸ï¸ Paused';
                    icon.className = 'fas fa-eye';
                    toggleBtn.title = 'Start Dart Detection';
                    toggleBtn.disabled = false;
                    break;
                case DartDetectorStatus.DETECTED:
                    dartStatusDot.classList.add('dart-detected');
                    dartStatusText.textContent = 'ðŸŽ¯ Impact Detected!';
                    toggleBtn.disabled = false;
                    break;
                default:
                    dartStatusDot.classList.add('dart-unknown');
                    dartStatusText.textContent = 'Not Started';
                    icon.className = 'fas fa-eye';
                    toggleBtn.title = 'Start Dart Detection';
                    toggleBtn.disabled = false;
                    break;
            }
        }

        // Initialize with default status
        updateDartDetectionStatus(-1, 'Not Started');

        // Initialize the canvas with debug overlay
        const zoomableCanvas = new ZoomablePannableCanvas('videoCanvas', 'canvasContainer', 'overlayCanvas');

        // Get DOM elements for camera manager
        const elements = {
            cameraSelect: document.getElementById("cameraSelect"),
            webcamPlayBtn: document.getElementById("webcamPlayBtn"),
            webcamStopBtn: document.getElementById("webcamStopBtn"),
            videoElement: document.getElementById("videoElement")
        };

        // Configuration options
        const options = {
            // Basic options
            autoSelectFirstCamera: true,

            onWebcamReady: (videoElement, resolution) => {
                console.log("Webcam ready with resolution:", resolution);
                if (zoomableCanvas) {
                    zoomableCanvas.setVideoSource(videoElement);
                }
            },

            onError: (error) => {
                console.error("Camera error:", error);
                // Custom error handling
                showErrorNotification(error.message);
            }
        };

        // Initialize CameraManager
        const cameraModal = new bootstrap.Modal(document.getElementById('cameraModal'));
        let cameraManager = new CameraManager({
            cameraSelect: null,
            webcamPlayBtn: document.getElementById("webcamPlayBtn"),
            webcamStopBtn: document.getElementById("webcamStopBtn"),
            videoElement: document.getElementById("videoElement")
        }, options);

        // Camera selection button handler
        document.getElementById('cameraSelectBtn').addEventListener('click', () => {
            const btn = document.getElementById('cameraSelectBtn');
            btn.disabled = true;
            cameraModal.show();
        });

        // Update camera manager to populate modal instead of dropdown
        options.onCamerasEnumerated = (cameras) => {
            const cameraList = document.getElementById('cameraList');
            cameraList.innerHTML = '';
            
            if (cameras.length === 0) {
                cameraList.innerHTML = '<div class="text-center">No cameras found</div>';
                return;
            }

            // Enable camera select button now that we have cameras
            const btn = document.getElementById('cameraSelectBtn');
            btn.disabled = false;
            btn.classList.remove('btn-loading');
            btn.innerHTML = '<i class="fas fa-camera"></i>';

            cameras.forEach((camera, index) => {
                const cameraCard = document.createElement('div');
                cameraCard.className = 'card bg-secondary text-white';
                cameraCard.style.width = '300px';
                cameraCard.style.cursor = 'pointer';
                cameraCard.innerHTML = `
                    <div class="card-body text-center">
                        <i class="fas fa-camera fa-3x mb-3"></i>
                        <h5 class="card-title">${camera.label || `Camera ${index + 1}`}</h5>
                    </div>
                `;
                cameraCard.addEventListener('click', () => {
                    cameraManager.selectCamera(camera.deviceId);
                    cameraModal.hide();
                    cameraManager.startWebcam();
                });
                cameraList.appendChild(cameraCard);
            });

            // Enable camera select button now that we have cameras
            document.getElementById('cameraSelectBtn').disabled = false;
        };

        // Setup webcam button handlers
        elements.webcamPlayBtn.onclick = () => {
            cameraManager.startWebcam();
            // Disable video file controls
            videoFilePlayBtn.disabled = true;
            videoFilePauseBtn.disabled = true;
            videoFileStopBtn.disabled = true;
            // Clear any video file
            document.getElementById('videoElement').src = '';
        };
        elements.webcamStopBtn.onclick = () => cameraManager.stopWebcam();

        // Set initial button states
        elements.webcamPlayBtn.disabled = true;
        elements.webcamStopBtn.disabled = true;

        // Update camera manager options to handle webcam state changes
        options.onWebcamReady = (videoElement, resolution) => {
            console.log("Webcam ready with resolution:", resolution);
            if (zoomableCanvas) {
                zoomableCanvas.setVideoSource(videoElement);
            }
            // Update button states
            elements.webcamPlayBtn.disabled = true;
            elements.webcamStopBtn.disabled = false;
        };

        options.onWebcamStopped = () => {
            // Re-enable video file controls when webcam stops
            videoFilePlayBtn.disabled = false;
            // Update webcam button states
            elements.webcamPlayBtn.disabled = false;
            elements.webcamStopBtn.disabled = true;
        };

        // Reinitialize CameraManager with updated options
        cameraManager = new CameraManager({
            cameraSelect: null,
            webcamPlayBtn: document.getElementById("webcamPlayBtn"),
            webcamStopBtn: document.getElementById("webcamStopBtn"),
            videoElement: document.getElementById("videoElement")
        }, options);

        // Video file functionality
        const videoFilePlayBtn = document.getElementById('videoFilePlayBtn');
        const videoFilePauseBtn = document.getElementById('videoFilePauseBtn');
        const videoFileStopBtn = document.getElementById('videoFileStopBtn');
        const videoFileSelectBtn = document.getElementById('videoFileSelectBtn');

        // Handle video file selection button click
        videoFileSelectBtn.addEventListener('click', () => {
            document.getElementById('videoFile').click();
        });

        document.getElementById('videoFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const videoElement = document.getElementById('videoElement');
                const url = URL.createObjectURL(file);
                videoElement.src = url;
                videoElement.loop = true;

                // Enable controls immediately when file is selected
                videoFilePlayBtn.disabled = false;
                videoFilePauseBtn.disabled = true;
                videoFileStopBtn.disabled = false;

                videoElement.addEventListener('loadedmetadata', () => {
                    videoElement.play().then(() => {
                        zoomableCanvas.setVideoSource(videoElement);
                        console.log('Video loaded and playing');

                        // Update video controls
                        videoFilePlayBtn.disabled = true;
                        videoFilePauseBtn.disabled = false;
                        videoFileStopBtn.disabled = false;

                        // Disable webcam controls
                        elements.webcamPlayBtn.disabled = true;
                        elements.webcamStopBtn.disabled = true;
                        cameraManager.stopWebcam();
                    }).catch(err => {
                        console.error('Error playing video:', err);
                    });
                }, { once: true });

                videoElement.addEventListener('play', () => {
                    videoFilePlayBtn.disabled = true;
                    videoFilePauseBtn.disabled = false;
                });

                videoElement.addEventListener('pause', () => {
                    videoFilePlayBtn.disabled = false;
                    videoFilePauseBtn.disabled = true;
                });

                videoElement.addEventListener('ended', () => {
                    videoFilePlayBtn.disabled = false;
                    videoFilePauseBtn.disabled = true;
                });

                // videoElement.addEventListener('error', (e) => {
                //     console.error('Video loading error:', e);
                //     alert('Could not load video file');
                //     // Reset controls on error
                //     videoFilePlayBtn.disabled = true;
                //     videoFilePauseBtn.disabled = true;
                //     videoFileStopBtn.disabled = true;
                // });
            }
        });

        // Video file control handlers
        videoFilePlayBtn.addEventListener('click', () => {
            const videoElement = document.getElementById('videoElement');
            videoElement.play();
            videoFilePlayBtn.disabled = true;
            videoFilePauseBtn.disabled = false;
        });

        videoFilePauseBtn.addEventListener('click', () => {
            const videoElement = document.getElementById('videoElement');
            videoElement.pause();
            videoFilePlayBtn.disabled = false;
            videoFilePauseBtn.disabled = true;
        });

        videoFileStopBtn.addEventListener('click', () => {
            const videoElement = document.getElementById('videoElement');
            
            // First clear the src to prevent further loading
            videoElement.src = '';
            
            // Then pause the video
            videoElement.pause();
            
            // Update UI controls
            videoFilePlayBtn.disabled = true;
            videoFilePauseBtn.disabled = true;
            videoFileStopBtn.disabled = true;

            // Re-enable webcam controls
            elements.webcamPlayBtn.disabled = false;
        });


        // Toggle detection button handler
        const toggleDetectionBtn = document.getElementById('toggleDetectionBtn');
        toggleDetectionBtn.addEventListener('click', () => {
            if (!dartnet.dartDetector) return;
            
            const icon = toggleDetectionBtn.querySelector('i');
            if (dartnet.dartDetector.currentStatus === DartDetectorStatus.DETECTING) {
                dartnet.dartDetector.stop();
                icon.className = 'fas fa-eye';
                toggleDetectionBtn.title = 'Start Dart Detection';
            } else {
                dartnet.dartDetector.start();
                icon.className = 'fas fa-arrows-to-dot';
                toggleDetectionBtn.title = 'Stop Dart Detection';
            }
        });

        let animationId = null;
        async function processFrame() {
            let wait = false;
            if (dartnet.dartDetector && dartnet.dartDetector.currentStatus != DartDetectorStatus.DETECTING && dartnet.dartDetector.currentStatus != DartDetectorStatus.DETECTED) wait = true;
            if (!dartnet.videoSource || dartnet.dartDetector?.pauseDetection || dartnet.videoSource.readyState !== dartnet.videoSource.HAVE_ENOUGH_DATA) wait = true;
            if (!wait) {
                try {
                    dartnet.detectDartImpact();
                } catch (err) {
                    console.error('Error processing frame:', err);
                }
            }
            animationId = requestAnimationFrame(processFrame);
        }
        processFrame();

        const autoCalib = async () => {
            console.log("Auto-calib start")
            dartnet.calibrate(onCalibrationSuccess)
        }

        autoCalibBtn.addEventListener('click', autoCalib);

        function recomputeUpTextPos() {
            const upText = PerspectiveUtils.transformPoints([
                [Math.cos(Math.PI * 1.5 + Math.PI / 20) * dartnet.board.r_double * 1.2,
                Math.sin(Math.PI * 1.5 + Math.PI / 20) * dartnet.board.r_double * 1.2]
            ], dartnet.Mi)[0];
            let el = zoomableCanvas.getOverlayElement("20");
            el.x = upText[0];
            el.y = upText[1];
        }

        function onCalibrationSuccess(calibPts) {
            console.log("Calibration succeed:", calibPts)
            for (let i = 0; i < calibPts.length; i++) {
                const p = calibPts[i];
                let el = zoomableCanvas.getOverlayElement(`calib${i}`);
                el.x = p[0];
                el.y = p[1];
            }
            recomputeUpTextPos();
        }

        for (let i = 0; i < 4; i++) {
            // Add interactive elements
            zoomableCanvas.addOverlayElement(`calib${i}`,
                { num: i, x: 100 + i * 20, y: -150, pt_radius: 2, circle_radius: i == 0 ? 14 : 10, color: classes_colors[i + 1] },
                // Draw callback
                (ctx, element, isSelected) => {
                    ctx.fillStyle = isSelected ? 'rgba(255, 255, 0, 0.7)' : element.color;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.pt_radius / zoomableCanvas.scale, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.strokeStyle = ctx.fillStyle;
                    ctx.lineWidth = (element.num == 0 ? 4 : 2) / zoomableCanvas.scale;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.circle_radius / zoomableCanvas.scale, 0, 2 * Math.PI);
                    ctx.stroke();
                },
                // Hit test callback (optional - defaults to circular)
                (element, worldX, worldY) => {
                    const dx = worldX - element.x;
                    const dy = worldY - element.y;
                    return Math.sqrt(dx * dx + dy * dy) <= element.circle_radius;
                }
            );
        }

        // Add "20" Element to help reorient in case it is needed
        zoomableCanvas.addOverlayElement("cropMask",
            {
                net: dartnet, x: 0, y: 0, color: 'rgba(0, 0, 0, 0.6)'
            },
            // Draw callback
            (ctx, element) => {
                const ca = element.net?.cropArea
                if (!ca) return;
                ctx.fillStyle = element.color;
                //ctx.lineWidth = 2 / zoomableCanvas.scale;
                ctx.fillRect(0, 0, zoomableCanvas.videoElement.videoWidth, ca[1]);
                ctx.fillRect(0, ca[3], zoomableCanvas.videoElement.videoWidth, zoomableCanvas.videoElement.videoHeight - ca[3]);
                ctx.fillRect(0, ca[1], 0, ca[3]);
                ctx.fillRect(ca[2], ca[1], zoomableCanvas.videoElement.videoWidth - ca[2], ca[3] - ca[1]);

                // ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                // ctx.strokeRect(ca[0], ca[1], ca[2]-ca[0], ca[3]-ca[1]);
            }
        );

        // Add "20" Element to help reorient in case it is needed
        zoomableCanvas.addOverlayElement("20",
            {
                net: dartnet, x: 0, y: 0, radius: 30, color: 'rgba(0, 255, 255, 0.5)', compute_possible: () => {
                    return PerspectiveUtils.transformPoints(
                        [...Array(20).keys()].map(i => {
                            const angle = Math.PI * 2 * i / 20 + Math.PI / 20;
                            const dis = dartnet.board.r_double * 1.2
                            return [Math.cos(angle) * dis, Math.sin(angle) * dis];
                        }), dartnet.Mi);
                }
            },
            // Draw callback
            (ctx, element, isSelected) => {
                ctx.fillStyle = isSelected ? 'rgba(128, 255, 128, 0.7)' : element.color;
                ctx.lineWidth = 2 / zoomableCanvas.scale;
                ctx.beginPath();
                ctx.arc(element.x, element.y, element.radius / zoomableCanvas.scale, 0, 2 * Math.PI);
                ctx.fill();

                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.font = `bold ${40 / zoomableCanvas.scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText("20", element.x, element.y + 14 / zoomableCanvas.scale);

                if (isSelected && element.net?.Mi) {
                    const possible = element.compute_possible()

                    possible.forEach((p) => {
                        ctx.fillStyle = 'rgba(0, 255, 255, 0.25)';
                        ctx.beginPath();
                        ctx.arc(p[0], p[1], 8 / zoomableCanvas.scale, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }
            },
            // Hit test callback (optional - defaults to circular)
            (element, worldX, worldY) => {
                const dx = worldX - element.x;
                const dy = worldY - element.y;
                return Math.sqrt(dx * dx + dy * dy) <= element.radius / zoomableCanvas.scale;
            }
        );

        // Add a virtual target visualizer
        zoomableCanvas.addOverlayElement('virtual_target',
            { net: dartnet, x: 10, y: 200, lineWidth: 2, color: 'rgba(0, 255, 255, 0.2)' },
            // Draw callback
            (ctx, element) => {
                const pts = element.net?.sourceCalibPts;
                const Mi = element.net?.Mi;
                const board = element.net?.board;
                if (!pts || !Mi || !board) return;
                ctx.strokeStyle = element.color;
                ctx.lineWidth = element.lineWidth / zoomableCanvas.scale;

                // Center drawing
                const srcCenter = PerspectiveUtils.transformPoints([[0, 0]], Mi)[0];
                ctx.beginPath();
                ctx.arc(srcCenter[0], srcCenter[1], 1 / zoomableCanvas.scale, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(srcCenter[0], srcCenter[1], 4 / zoomableCanvas.scale, 0, 2 * Math.PI);
                ctx.stroke();

                // Segments drawing
                const boardOuter = board.getOuterPts()
                const srcOuter = PerspectiveUtils.transformPoints(boardOuter, Mi);
                const segStart = PerspectiveUtils.transformPoints(boardOuter.map((p) => {
                    const ratio = board.r_outer_bull / Math.sqrt(p[0] * p[0] + p[1] * p[1]);
                    return [p[0] * ratio, p[1] * ratio];
                }), Mi)
                ctx.beginPath();
                for (let i = 0; i < segStart.length; i++) {
                    ctx.moveTo(segStart[i][0], segStart[i][1]);
                    ctx.lineTo(srcOuter[i][0], srcOuter[i][1]);
                }
                ctx.stroke();

                // Circles drawing
                const radii = [board.r_inner_bull, board.r_outer_bull, board.r_double - board.w_double_treble,
                board.r_double,
                board.r_treble - board.w_double_treble, board.r_treble
                ]

                radii.forEach((r) => {
                    const num = Math.max(Math.ceil(r * 200 * (zoomableCanvas.scale < 1 ? 1 : zoomableCanvas.scale)), 20);
                    const pts = [...Array(num).keys()].map(i => [Math.cos(Math.PI * 2 * i / num) * r, Math.sin(Math.PI * 2 * i / num) * r]);
                    const srcPts = PerspectiveUtils.transformPoints(pts, Mi);
                    ctx.beginPath();
                    ctx.moveTo(srcPts[0], srcPts[1])
                    for (let i = 0; i <= srcPts.length; i++) {
                        p = srcPts[(i + 1) % srcPts.length];
                        ctx.lineTo(p[0], p[1]);
                    }
                    ctx.stroke();
                });
            }
        );

        // Add score viewer on mouse hover
        zoomableCanvas.addOverlayElement("scoreViewer", { x: 0, y: 0, color: 'rgba(0, 255, 128, 0.75)', text: null },
            // Draw callback
            (ctx, element) => {
                if (!element.text) return;
                ctx.fillStyle = element.color;
                ctx.font = `bold ${20 / zoomableCanvas.scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(element.text, element.x, element.y + 14 / zoomableCanvas.scale);
            },
            (element, worldX, worldY) => false // Disable picking drag and drop
        );

        // Add Dart tip debug viewer
        zoomableCanvas.addOverlayElement("dartTip", { x: 40, y: 0, pt_radius: 1.5, radius: 10, color: 'rgba(0, 128, 255, 0.5)' },
            // Draw callback
            (ctx, element) => {
                //if(!element.text) return;
                ctx.fillStyle = element.color;
                ctx.beginPath();
                ctx.arc(element.x, element.y, element.pt_radius / zoomableCanvas.scale, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = element.color;
                ctx.lineWidth = 1 / zoomableCanvas.scale;
                ctx.beginPath();
                let dec = element.radius / zoomableCanvas.scale;
                ctx.moveTo(element.x - dec, element.y - dec);
                ctx.lineTo(element.x + dec, element.y + dec);
                ctx.moveTo(element.x + dec, element.y - dec);
                ctx.lineTo(element.x - dec, element.y + dec);
                ctx.stroke();

                // ctx.font = `bold ${20 / zoomableCanvas.scale}px Arial`;
                // ctx.textAlign = 'center';
                // ctx.fillText(element.text, element.x, element.y + 14/ zoomableCanvas.scale);
            },
            (element, worldX, worldY) => false // Disable picking drag and drop
        );

        // Add Dart tip debug viewer
        zoomableCanvas.addOverlayElement("dartDebug", { x: 0, y: 0, boxes: null },
            // Draw callback
            (ctx, element) => {
                if (!element.boxes) return;
                element.boxes.forEach((b) => {
                    ctx.strokeStyle = classes_colors[b[4]];
                    ctx.lineWidth = 1.5 / zoomableCanvas.scale;
                    ctx.strokeRect(b[0], b[1], b[2] - b[0], b[3] - b[1]);

                });

                // ctx.font = `bold ${20 / zoomableCanvas.scale}px Arial`;
                // ctx.textAlign = 'center';
                // ctx.fillText(element.text, element.x, element.y + 14/ zoomableCanvas.scale);
            },
            (element, worldX, worldY) => false // Disable picking drag and drop
        );


        // Add "20" Element to help reorient in case it is needed
        zoomableCanvas.addOverlayElement("scoreViewer", { x: 0, y: 0, color: 'rgba(0, 255, 128, 0.75)', text: null },
            // Draw callback
            (ctx, element) => {
                if (!element.text) return;
                ctx.fillStyle = element.color;
                ctx.font = `bold ${20 / zoomableCanvas.scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(element.text, element.x, element.y + 14 / zoomableCanvas.scale);
            },
            (element, worldX, worldY) => false // Disable picking drag and drop
        );



        // Add "20" Element to help reorient in case it is needed
        zoomableCanvas.addOverlayElement("dartImpactDebug",
            {
                img: null, width: 0, height: 0, net: dartnet, x: 0, y: 0, color: [255, 0, 0, 0.8], setDetected(grayImg, width, height) {
                    const imageData = new ImageData(width, height);
                    const data = imageData.data;

                    for (let i = 0; i < grayImg.data.length; i++) {
                        const value = grayImg.data[i];
                        data[i * 4] = Math.floor(value * this.color[0] / 255); // R
                        data[i * 4 + 1] = Math.floor(value * this.color[1] / 255); // G
                        data[i * 4 + 2] = Math.floor(value * this.color[2] / 255); // B
                        data[i * 4 + 3] = Math.floor((value < 20 ? 0 : 1) * this.color[3] * 255); // A
                    }
                    this.img = ImageProcessor.imageDataToImage(imageData);
                    this.width = width;
                    this.height = height;
                }
            },
            // Draw callback
            (ctx, element) => {
                const ca = element.net?.cropArea;
                if (!ca || !element.img) return;

                ctx.drawImage(element.img, 0, 0, element.width, element.height, ca[0], ca[1], ca[2], ca[3]);
            }
        );

        // Set up event callbacks
        zoomableCanvas.setOnElementSelected((id, element) => {
            console.log(`Selected element: ${id}`, element);
        });

        zoomableCanvas.setOnElementDrag((id, element, worldCoords) => {
            console.log(`Dragging ${id} to:`, element.x, element.y);

            if (id.includes("calib")) {
                console.log(`Moving calibration point ${element.num}`)
                if (dartnet.sourceCalibPts) {
                    dartnet.sourceCalibPts[element.num] = [element.x, element.y];
                    dartnet.updateCalibPoints(dartnet.sourceCalibPts);
                }
            }
            else if (id == "20") {
                const possible = element.compute_possible();
                const distances = possible.map((p) => MathUtils.distance(p, [element.x, element.y]))
                var indexMin = distances.indexOf(Math.min(...distances));
                var rotMatrix = MathUtils.createRotationMatrix(((indexMin + 5) % 30) * 360 / 20);
                var boardRotated = MathUtils.rotatePoints(dartnet.board.board_cal_pts, rotMatrix);
                var newCalib = PerspectiveUtils.transformPoints(boardRotated, dartnet.Mi)
                dartnet.updateCalibPoints(newCalib);
                onCalibrationSuccess(newCalib);
            }
        });

        zoomableCanvas.setOnElementDragEnd((id, element, worldCoords) => {
            console.log(`Finished dragging ${id}`);
        });

        document.getElementById("videoCanvas").addEventListener('mousemove', (event) => {
            const srcP = zoomableCanvas.canvasToWorld(event.clientX, event.clientY);
            const score = dartnet.sourceCalibPts ? dartnet.board.getDartScores(dartnet.sourceCalibPts, [[srcP.x, srcP.y]])[0] : null;
            let element = zoomableCanvas.getOverlayElement("scoreViewer");
            element.x = srcP.x + 40 / zoomableCanvas.scale;
            element.y = srcP.y;
            element.text = score;
        });

        function onDartDetected(data) {
            //console.log("DartImpact:", data);

            const debugCanvas = document.getElementById("debugCanvas");
            if (debugCanvas) {
                debugCanvas.width = 640;
                debugCanvas.height = 640;

                const debugCtx = debugCanvas.getContext("2d");
                debugCtx.putImageData(ImageProcessor.grayscaleToImageData(data.delta), 0, 0);
                debugCtx.strokeStyle = "rgba(255, 255, 0, 1.0)";
                data.boxes.forEach((b) => {
                    debugCtx.strokeRect(b[0], b[1], b[2] - b[0], b[3] - b[1]);
                });
            }

            zoomableCanvas.getOverlayElement("dartImpactDebug").setDetected(data.delta, dartnet.dartDetector.modelSize, dartnet.dartDetector.modelSize);

            const confidencesTips = data.boxes.map((b) => b[4] === 0 ? b[5] : 0.0);
            if(dartnet.targetDetector && confidencesTips && confidencesTips.length) {
                var indexMax = confidencesTips.indexOf(Math.max(...confidencesTips));
                const b = data.boxes[indexMax];
                const srcP = dartnet.cropppedToSource([(b[0]+b[2])*0.5, (b[1]+b[3])*0.5])
                const tipEl = zoomableCanvas.getOverlayElement("dartTip");
                if(tipEl) {
                    tipEl.x = srcP[0];
                    tipEl.y = srcP[1];
                }
                //console.log(dartnet.sourceCalibPts, srcP);
                var score  = dartnet.sourceCalibPts ? dartnet.board.getDartScores(dartnet.sourceCalibPts, [[srcP[0], srcP[1]]])[0] : null;
                console.log("HIT ZONE:", score);
                Sound.zone(score);
            }

            const dartDbg = zoomableCanvas.getOverlayElement("dartDebug");
            dartDbg.boxes = data.boxes.map((b) => {
                let tl = dartnet.cropppedToSource([b[0], b[1]]);
                let br = dartnet.cropppedToSource([b[2], b[3]]);
                return [tl[0], tl[1], br[0], br[1], b[4], b[5]];
            });
        }

    </script>
</body>

</html>
