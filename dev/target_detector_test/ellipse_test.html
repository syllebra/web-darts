<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robust Ellipse Distance Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        canvas {
            border: 2px solid #333;
            cursor: crosshair;
            display: block;
            margin: 20px auto;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #45a049;
        }
        .info {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .status {
            font-weight: bold;
            margin: 10px 0;
        }
        .algorithm-info {
            background: #f9f9f9;
            padding: 10px;
            border-left: 4px solid #4CAF50;
            margin: 10px 0;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Robust Ellipse Distance Calculator</h1>
        <div class="info">
            <p><strong>Instructions:</strong></p>
            <ul>
                <li>Click on the canvas to place test points</li>
                <li>Green line shows the computed closest point on the ellipse</li>
                <li>Red point = outside ellipse, Orange point = inside ellipse</li>
                <li>Blue point is the closest point on ellipse</li>
                <li>Distance and inside/outside status shown in text</li>
            </ul>
        </div>
        
        <div class="algorithm-info">
            <strong>Algorithm:</strong> Uses a robust hybrid approach that combines analytical vertex checks with 
            Newton-Raphson iteration, ensuring correct handling of edge cases and far points.
        </div>
        
        <canvas id="canvas" width="800" height="600"></canvas>
        
        <div class="controls">
            <button onclick="clearPoints()">Clear Points</button>
            <button onclick="changeEllipse()">Change Ellipse</button>
            <button onclick="testKnownCases()">Test Known Cases</button>
            <button onclick="testEdgeCases()">Test Edge Cases</button>
            <button onclick="testFarPoints()">Test Far Points</button>
        </div>
        
        <div class="status" id="status">Click on canvas to test points</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Test ellipse parameters
        let ellipse = {
            center: [400, 300],
            axes: [150, 100],
            angle: Math.PI / 6  // 30 degrees
        };
        
        let testPoints = [];
        
        // Robust ellipse distance calculation functions
        function isPointInsideEllipse(point, ellipse) {
            const [px, py] = point;
            const [cx, cy] = ellipse.center;
            const [a, b] = ellipse.axes;
            const angle = ellipse.angle;
            
            // Transform point to ellipse coordinate system
            const cos_angle = Math.cos(-angle);
            const sin_angle = Math.sin(-angle);
            
            const tx = (px - cx) * cos_angle - (py - cy) * sin_angle;
            const ty = (px - cx) * sin_angle + (py - cy) * cos_angle;
            
            // Check if point is inside ellipse: (x/a)² + (y/b)² <= 1
            const normalized = (tx * tx) / (a * a) + (ty * ty) / (b * b);
            return normalized <= 1.0;
        }
        
        function pointToEllipseDistance(point, ellipse) {
            const [px, py] = point;
            const [cx, cy] = ellipse.center;
            const [a, b] = ellipse.axes;
            const angle = ellipse.angle;
            
            // Transform point to ellipse coordinate system
            const cos_angle = Math.cos(-angle);
            const sin_angle = Math.sin(-angle);
            
            const tx = (px - cx) * cos_angle - (py - cy) * sin_angle;
            const ty = (px - cx) * sin_angle + (py - cy) * cos_angle;
            
            // Find closest point on ellipse using robust algorithm
            const closest = robustClosestPointOnEllipse(tx, ty, a, b);
            
            // Transform closest point back to original coordinate system
            const cos_angle_back = Math.cos(angle);
            const sin_angle_back = Math.sin(angle);
            
            const closest_x = closest[0] * cos_angle_back - closest[1] * sin_angle_back + cx;
            const closest_y = closest[0] * sin_angle_back + closest[1] * cos_angle_back + cy;
            
            // Calculate Euclidean distance
            const dx = px - closest_x;
            const dy = py - closest_y;
            
            return {
                distance: Math.sqrt(dx * dx + dy * dy),
                closestPoint: [closest_x, closest_y]
            };
        }
        
        function robustClosestPointOnEllipse(px, py, a, b) {
            // Handle degenerate cases
            if (a <= 0 || b <= 0) {
                return [0, 0];
            }
            
            // Ensure a >= b for consistency (swap if needed)
            let swapped = false;
            if (b > a) {
                [a, b] = [b, a];
                [px, py] = [py, px];
                swapped = true;
            }
            
            // Work with absolute values and restore signs later
            const sign_x = Math.sign(px);
            const sign_y = Math.sign(py);
            px = Math.abs(px);
            py = Math.abs(py);
            
            // Special cases
            if (px === 0 && py === 0) {
                let result = [a, 0];
                if (swapped) result = [result[1], result[0]];
                return [result[0] * sign_x, result[1] * sign_y];
            }
            
            if (py === 0) {
                let result = [a, 0];
                if (swapped) result = [result[1], result[0]];
                return [result[0] * sign_x, result[1] * sign_y];
            }
            
            if (px === 0) {
                let result = [0, b];
                if (swapped) result = [result[1], result[0]];
                return [result[0] * sign_x, result[1] * sign_y];
            }
            
            // Check if the closest point might be at vertices
            const vertices = [
                [a, 0],   // Right vertex
                [0, b],   // Top vertex
                [-a, 0],  // Left vertex
                [0, -b]   // Bottom vertex
            ];
            
            let bestDistance = Infinity;
            let bestPoint = [a, 0];
            
            // Check all vertices
            for (const vertex of vertices) {
                const vx = Math.abs(vertex[0]);
                const vy = Math.abs(vertex[1]);
                const dist = Math.sqrt((px - vx) * (px - vx) + (py - vy) * (py - vy));
                if (dist < bestDistance) {
                    bestDistance = dist;
                    bestPoint = [vx, vy];
                }
            }
            
            // Use Newton-Raphson to find the closest point
            // The closest point satisfies: (x-px)/a² = (y-py)/b² = λ
            let t = Math.atan2(py * a, px * b); // Initial guess
            
            for (let iteration = 0; iteration < 50; iteration++) {
                const cos_t = Math.cos(t);
                const sin_t = Math.sin(t);
                
                const ex = a * cos_t;
                const ey = b * sin_t;
                
                // Vector from ellipse point to target point
                const rx = ex - px;
                const ry = ey - py;
                
                // Tangent vector
                const qx = -a * sin_t;
                const qy = b * cos_t;
                
                // First derivative of distance squared
                const f = rx * qx + ry * qy;
                
                // Second derivative of distance squared
                const df = qx * qx + qy * qy + rx * (-a * cos_t) + ry * (-b * sin_t);
                
                if (Math.abs(f) < 1e-12 || Math.abs(df) < 1e-12) {
                    break;
                }
                
                const delta = f / df;
                t = t - delta;
                
                if (Math.abs(delta) < 1e-12) {
                    break;
                }
            }
            
            // Calculate the candidate point from Newton-Raphson
            const candidate_x = a * Math.cos(t);
            const candidate_y = b * Math.sin(t);
            
            // Check if the Newton-Raphson solution is better
            const nr_dist = Math.sqrt((px - candidate_x) * (px - candidate_x) + (py - candidate_y) * (py - candidate_y));
            
            if (nr_dist < bestDistance) {
                bestPoint = [candidate_x, candidate_y];
                bestDistance = nr_dist;
            }
            
            // Additional robustness: try multiple starting points for Newton-Raphson
            const startingAngles = [0, Math.PI/2, Math.PI, 3*Math.PI/2, Math.atan2(py, px)];
            
            for (const startAngle of startingAngles) {
                t = startAngle;
                
                for (let iteration = 0; iteration < 30; iteration++) {
                    const cos_t = Math.cos(t);
                    const sin_t = Math.sin(t);
                    
                    const ex = a * cos_t;
                    const ey = b * sin_t;
                    
                    const rx = ex - px;
                    const ry = ey - py;
                    
                    const qx = -a * sin_t;
                    const qy = b * cos_t;
                    
                    const f = rx * qx + ry * qy;
                    const df = qx * qx + qy * qy + rx * (-a * cos_t) + ry * (-b * sin_t);
                    
                    if (Math.abs(f) < 1e-12 || Math.abs(df) < 1e-12) {
                        break;
                    }
                    
                    const delta = f / df;
                    t = t - delta;
                    
                    if (Math.abs(delta) < 1e-12) {
                        break;
                    }
                }
                
                const test_x = a * Math.cos(t);
                const test_y = b * Math.sin(t);
                const test_dist = Math.sqrt((px - test_x) * (px - test_x) + (py - test_y) * (py - test_y));
                
                if (test_dist < bestDistance) {
                    bestPoint = [test_x, test_y];
                    bestDistance = test_dist;
                }
            }
            
            // Restore signs
            bestPoint[0] *= sign_x;
            bestPoint[1] *= sign_y;
            
            // Restore coordinate order if we swapped
            if (swapped) {
                bestPoint = [bestPoint[1], bestPoint[0]];
            }
            
            return bestPoint;
        }
        
        function drawEllipse(ctx, ellipse) {
            ctx.save();
            ctx.translate(ellipse.center[0], ellipse.center[1]);
            ctx.rotate(ellipse.angle);
            
            ctx.beginPath();
            ctx.ellipse(0, 0, ellipse.axes[0], ellipse.axes[1], 0, 0, 2 * Math.PI);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw axes for reference
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-ellipse.axes[0], 0);
            ctx.lineTo(ellipse.axes[0], 0);
            ctx.moveTo(0, -ellipse.axes[1]);
            ctx.lineTo(0, ellipse.axes[1]);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawPoint(ctx, point, color, size = 5) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(point[0], point[1], size, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        function drawLine(ctx, p1, p2, color, width = 2) {
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(p1[0], p1[1]);
            ctx.lineTo(p2[0], p2[1]);
            ctx.stroke();
        }
        
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ellipse
            drawEllipse(ctx, ellipse);
            
            // Draw center point
            drawPoint(ctx, ellipse.center, '#888', 3);
            
            // Draw test points and their closest points
            testPoints.forEach((point, index) => {
                const result = pointToEllipseDistance(point, ellipse);
                const isInside = isPointInsideEllipse(point, ellipse);
                
                // Draw test point (red for outside, orange for inside)
                drawPoint(ctx, point, isInside ? '#ff8800' : '#ff0000', 6);
                
                // Draw closest point (blue)
                drawPoint(ctx, result.closestPoint, '#0000ff', 4);
                
                // Draw connection line (green)
                drawLine(ctx, point, result.closestPoint, '#00ff00', 2);
                
                // Add text showing distance and inside/outside status
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.fillText(`d=${result.distance.toFixed(2)}${isInside ? ' (IN)' : ' (OUT)'}`, 
                    point[0] + 10, point[1] - 10);
            });
        }
        
        function clearPoints() {
            testPoints = [];
            render();
            document.getElementById('status').textContent = 'Points cleared. Click on canvas to test points.';
        }
        
        function changeEllipse() {
            ellipse = {
                center: [400, 300],
                axes: [Math.random() * 120 + 30, Math.random() * 120 + 30],
                angle: Math.random() * Math.PI * 2
            };
            render();
            document.getElementById('status').textContent = 'New ellipse generated.';
        }
        
        function testKnownCases() {
            testPoints = [];
            
            // Test points along major and minor axes
            const [cx, cy] = ellipse.center;
            const [a, b] = ellipse.axes;
            const angle = ellipse.angle;
            
            // Points along major axis
            const majorAxisX = Math.cos(angle);
            const majorAxisY = Math.sin(angle);
            
            // Points along minor axis
            const minorAxisX = -Math.sin(angle);
            const minorAxisY = Math.cos(angle);
            
            // Add test points
            testPoints.push([cx + (a + 20) * majorAxisX, cy + (a + 20) * majorAxisY]); // Outside major axis
            testPoints.push([cx + (b + 20) * minorAxisX, cy + (b + 20) * minorAxisY]); // Outside minor axis
            testPoints.push([cx, cy]); // Center
            testPoints.push([cx + 50, cy + 50]); // Random point
            
            render();
            document.getElementById('status').textContent = 'Known test cases loaded.';
        }
        
        function testEdgeCases() {
            testPoints = [];
            const [cx, cy] = ellipse.center;
            const [a, b] = ellipse.axes;
            const angle = ellipse.angle;
            
            // Transform to get actual vertex positions
            const cos_angle = Math.cos(angle);
            const sin_angle = Math.sin(angle);
            
            // Add points very close to vertices
            testPoints.push([cx + a * cos_angle + 1, cy + a * sin_angle + 1]); // Near right vertex
            testPoints.push([cx - b * sin_angle + 1, cy + b * cos_angle + 1]); // Near top vertex
            testPoints.push([cx - a * cos_angle - 1, cy - a * sin_angle - 1]); // Near left vertex
            testPoints.push([cx + b * sin_angle - 1, cy - b * cos_angle - 1]); // Near bottom vertex
            
            render();
            document.getElementById('status').textContent = 'Edge cases loaded (points near vertices).';
        }
        
        function testFarPoints() {
            testPoints = [];
            const [cx, cy] = ellipse.center;
            
            // Add points very far from the ellipse
            testPoints.push([cx + 300, cy + 200]); // Far northeast
            testPoints.push([cx - 250, cy + 150]); // Far northwest
            testPoints.push([cx - 200, cy - 180]); // Far southwest
            testPoints.push([cx + 280, cy - 220]); // Far southeast
            testPoints.push([cx, cy + 250]); // Far north
            testPoints.push([cx + 350, cy]); // Far east
            
            render();
            document.getElementById('status').textContent = 'Far points loaded (should correctly identify vertex connections).';
        }
        
        // Mouse click event
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            testPoints.push([x, y]);
            render();
            
            if (testPoints.length > 0) {
                const lastPoint = testPoints[testPoints.length - 1];
                const result = pointToEllipseDistance(lastPoint, ellipse);
                const isInside = isPointInsideEllipse(lastPoint, ellipse);
                document.getElementById('status').textContent = 
                    `Point added at (${x.toFixed(1)}, ${y.toFixed(1)}). Distance: ${result.distance.toFixed(2)} ${isInside ? '(inside)' : '(outside)'}`;
            }
        });
        
        // Initial render
        render();
    </script>
</body>
</html>