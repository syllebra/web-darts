<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLO v11 ONNX Inference</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/onnxruntime-web/1.17.1/ort.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        label {
            font-weight: bold;
            color: #555;
        }
        input, select, button {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        button {
            cursor: pointer;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        .canvas-container {
            position: relative;
            margin: 20px 0;
            text-align: center;
        }
        canvas {
            max-width: 100%;
            border: 3px solid #ddd;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        .results {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }
        .detection-item {
            background: white;
            margin: 10px 0;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #28a745;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-weight: bold;
        }
        .status.info { background: #d1ecf1; color: #0c5460; border-left: 4px solid #17a2b8; }
        .status.success { background: #d4edda; color: #155724; border-left: 4px solid #28a745; }
        .status.error { background: #f8d7da; color: #721c24; border-left: 4px solid #dc3545; }
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç YOLO v11 Object Detection</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="modelFile">ONNX Model File:</label>
                <input type="file" id="modelFile" accept=".onnx" />
            </div>
            
            <div class="control-group">
                <label for="imageFile">Image File:</label>
                <input type="file" id="imageFile" accept="image/*" />
            </div>
            
            <div class="control-group">
                <label for="inputSize">Input Size:</label>
                <input type="number" id="inputSize" value="640" min="320" max="1280" step="32" />
            </div>
            
            <div class="control-group">
                <label for="backend">Backend:</label>
                <select id="backend">
                    <option value="webgpu">WebGPU</option>
                    <option value="wasm">CPU (WASM)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="confidenceThreshold">Confidence Threshold:</label>
                <input type="range" id="confidenceThreshold" min="0.1" max="1.0" step="0.05" value="0.5" />
                <span id="confidenceValue">0.5</span>
            </div>
            
            <div class="control-group">
                <label for="iouThreshold">IoU Threshold:</label>
                <input type="range" id="iouThreshold" min="0.1" max="1.0" step="0.05" value="0.45" />
                <span id="iouValue">0.45</span>
            </div>
        </div>
        
        <button id="runInference" disabled>üöÄ Run Inference</button>
        
        <div id="status"></div>
        <div id="progressContainer" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        
        <div id="results" class="results" style="display: none;">
            <h3>Detection Results:</h3>
            <div id="detectionsList"></div>
        </div>
    </div>

    <script>
        class YOLOv11Inference {
            constructor() {
                this.session = null;
                this.inputSize = 640;
                this.confidenceThreshold = 0.5;
                this.iouThreshold = 0.45;
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // COCO class names for YOLO
                this.classNames = [
                    'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
                    'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
                    'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
                    'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
                    'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
                    'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
                    'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake',
                    'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop',
                    'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink',
                    'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
                ];
                
                this.colors = this.generateColors(this.classNames.length);
                this.initializeEventListeners();
            }
            
            generateColors(numColors) {
                const colors = [];
                for (let i = 0; i < numColors; i++) {
                    const hue = (i * 137.508) % 360; // Golden angle approximation
                    colors.push(`hsl(${hue}, 70%, 50%)`);
                }
                return colors;
            }
            
            initializeEventListeners() {
                const elements = {
                    modelFile: document.getElementById('modelFile'),
                    imageFile: document.getElementById('imageFile'),
                    inputSize: document.getElementById('inputSize'),
                    backend: document.getElementById('backend'),
                    confidenceThreshold: document.getElementById('confidenceThreshold'),
                    iouThreshold: document.getElementById('iouThreshold'),
                    runInference: document.getElementById('runInference')
                };
                
                elements.modelFile.addEventListener('change', () => this.checkReadiness());
                elements.imageFile.addEventListener('change', () => this.checkReadiness());
                elements.inputSize.addEventListener('change', (e) => {
                    this.inputSize = parseInt(e.target.value);
                });
                
                elements.confidenceThreshold.addEventListener('input', (e) => {
                    this.confidenceThreshold = parseFloat(e.target.value);
                    document.getElementById('confidenceValue').textContent = e.target.value;
                });
                
                elements.iouThreshold.addEventListener('input', (e) => {
                    this.iouThreshold = parseFloat(e.target.value);
                    document.getElementById('iouValue').textContent = e.target.value;
                });
                
                elements.runInference.addEventListener('click', () => this.runInference());
            }
            
            checkReadiness() {
                const modelFile = document.getElementById('modelFile').files[0];
                const imageFile = document.getElementById('imageFile').files[0];
                const runButton = document.getElementById('runInference');
                
                runButton.disabled = !(modelFile && imageFile);
            }
            
            showStatus(message, type = 'info') {
                const statusDiv = document.getElementById('status');
                statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
            }
            
            showProgress(progress) {
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                
                if (progress === 0) {
                    progressContainer.style.display = 'none';
                } else {
                    progressContainer.style.display = 'block';
                    progressFill.style.width = `${progress}%`;
                }
            }
            
            async loadModel() {
                const modelFile = document.getElementById('modelFile').files[0];
                const backend = document.getElementById('backend').value;
                
                if (!modelFile) throw new Error('No model file selected');
                
                this.showStatus('Loading ONNX model...', 'info');
                this.showProgress(20);
                
                // Configure ONNX Runtime
                ort.env.wasm.wasmPaths = 'https://cdnjs.cloudflare.com/ajax/libs/onnxruntime-web/1.17.1/';
                
                const providers = backend === 'webgpu' ? ['webgpu', 'wasm'] : ['wasm'];
                
                try {
                    const arrayBuffer = await modelFile.arrayBuffer();
                    this.showProgress(60);
                    
                    this.session = await ort.InferenceSession.create(arrayBuffer, {
                        executionProviders: providers
                    });
                    
                    this.showProgress(80);
                    this.showStatus(`Model loaded successfully with ${backend.toUpperCase()} backend`, 'success');
                    
                    // Log model info
                    console.log('Model input names:', this.session.inputNames);
                    console.log('Model output names:', this.session.outputNames);
                    
                } catch (error) {
                    throw new Error(`Failed to load model: ${error.message}`);
                }
            }
            
            async preprocessImage(imageFile) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        try {
                            // Set canvas size to input size
                            this.canvas.width = this.inputSize;
                            this.canvas.height = this.inputSize;
                            
                            // Calculate scaling and padding to maintain aspect ratio
                            const scale = Math.min(this.inputSize / img.width, this.inputSize / img.height);
                            const scaledWidth = img.width * scale;
                            const scaledHeight = img.height * scale;
                            const offsetX = (this.inputSize - scaledWidth) / 2;
                            const offsetY = (this.inputSize - scaledHeight) / 2;
                            
                            // Clear canvas and draw image
                            this.ctx.fillStyle = '#808080'; // Gray padding
                            this.ctx.fillRect(0, 0, this.inputSize, this.inputSize);
                            this.ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
                            
                            // Get image data and convert to tensor format
                            const imageData = this.ctx.getImageData(0, 0, this.inputSize, this.inputSize);
                            const { data } = imageData;
                            
                            // Convert RGBA to RGB and normalize to [0, 1]
                            const red = [], green = [], blue = [];
                            for (let i = 0; i < data.length; i += 4) {
                                red.push(data[i] / 255.0);
                                green.push(data[i + 1] / 255.0);
                                blue.push(data[i + 2] / 255.0);
                            }
                            
                            // Combine channels in CHW format
                            const tensor = new Float32Array([...red, ...green, ...blue]);
                            
                            resolve({
                                tensor,
                                originalWidth: img.width,
                                originalHeight: img.height,
                                scale,
                                offsetX,
                                offsetY
                            });
                        } catch (error) {
                            reject(error);
                        }
                    };
                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = URL.createObjectURL(imageFile);
                });
            }
            
            nonMaxSuppression(boxes, scores, classes, iou_threshold) {
                const indices = [];
                const areas = boxes.map(box => (box[2] - box[0]) * (box[3] - box[1]));
                
                // Sort by score (descending)
                const sortedIndices = Array.from({ length: scores.length }, (_, i) => i)
                    .sort((a, b) => scores[b] - scores[a]);
                
                const suppressed = new Array(boxes.length).fill(false);
                
                for (const i of sortedIndices) {
                    if (suppressed[i]) continue;
                    
                    indices.push(i);
                    
                    for (let j = i + 1; j < boxes.length; j++) {
                        if (suppressed[j]) continue;
                        
                        // Calculate IoU
                        const x1 = Math.max(boxes[i][0], boxes[j][0]);
                        const y1 = Math.max(boxes[i][1], boxes[j][1]);
                        const x2 = Math.min(boxes[i][2], boxes[j][2]);
                        const y2 = Math.min(boxes[i][3], boxes[j][3]);
                        
                        const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
                        const union = areas[i] + areas[j] - intersection;
                        const iou = intersection / union;
                        
                        if (iou > iou_threshold && classes[i] === classes[j]) {
                            suppressed[j] = true;
                        }
                    }
                }
                
                return indices;
            }
            
            postprocessOutputs(outputs, imageInfo) {
                // YOLO v11 typically outputs shape [batch, 84, anchors] where 84 = 4 (bbox) + 80 (classes)
                const output = outputs[this.session.outputNames[0]];
                const outputData = output.data;
                const [batchSize, numChannels, numAnchors] = output.dims;
                
                console.log('Output shape:', output.dims);
                
                const boxes = [];
                const scores = [];
                const classes = [];
                
                // Process each anchor
                for (let i = 0; i < numAnchors; i++) {
                    const baseIdx = i * numChannels;
                    
                    // Extract bbox coordinates (center x, center y, width, height)
                    const cx = outputData[baseIdx + 0];
                    const cy = outputData[baseIdx + 1];
                    const w = outputData[baseIdx + 2];
                    const h = outputData[baseIdx + 3];
                    
                    // Find best class and confidence
                    let maxScore = 0;
                    let bestClass = 0;
                    
                    for (let c = 4; c < numChannels; c++) {
                        const score = outputData[baseIdx + c];
                        if (score > maxScore) {
                            maxScore = score;
                            bestClass = c - 4;
                        }
                    }
                    
                    // Apply confidence threshold
                    if (maxScore > this.confidenceThreshold) {
                        // Convert to corner coordinates and scale back to original image
                        const x1 = (cx - w / 2 - imageInfo.offsetX) / imageInfo.scale;
                        const y1 = (cy - h / 2 - imageInfo.offsetY) / imageInfo.scale;
                        const x2 = (cx + w / 2 - imageInfo.offsetX) / imageInfo.scale;
                        const y2 = (cy + h / 2 - imageInfo.offsetY) / imageInfo.scale;
                        
                        boxes.push([
                            Math.max(0, x1),
                            Math.max(0, y1),
                            Math.min(imageInfo.originalWidth, x2),
                            Math.min(imageInfo.originalHeight, y2)
                        ]);
                        scores.push(maxScore);
                        classes.push(bestClass);
                    }
                }
                
                // Apply Non-Maximum Suppression
                const keepIndices = this.nonMaxSuppression(boxes, scores, classes, this.iouThreshold);
                
                return keepIndices.map(i => ({
                    bbox: boxes[i],
                    score: scores[i],
                    class: classes[i],
                    className: this.classNames[classes[i]] || `Class ${classes[i]}`
                }));
            }
            
            drawDetections(detections, imageInfo) {
                // Redraw original image
                const img = new Image();
                img.onload = () => {
                    // Clear canvas and resize to original image dimensions
                    this.canvas.width = imageInfo.originalWidth;
                    this.canvas.height = imageInfo.originalHeight;
                    this.ctx.drawImage(img, 0, 0);
                    
                    // Draw detections
                    detections.forEach((detection, i) => {
                        const [x1, y1, x2, y2] = detection.bbox;
                        const color = this.colors[detection.class % this.colors.length];
                        
                        // Draw bounding box
                        this.ctx.strokeStyle = color;
                        this.ctx.lineWidth = 3;
                        this.ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                        
                        // Draw label background
                        const label = `${detection.className} ${(detection.score * 100).toFixed(1)}%`;
                        this.ctx.font = 'bold 16px Arial';
                        const textWidth = this.ctx.measureText(label).width;
                        
                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(x1, y1 - 25, textWidth + 10, 25);
                        
                        // Draw label text
                        this.ctx.fillStyle = 'white';
                        this.ctx.fillText(label, x1 + 5, y1 - 8);
                    });
                };
                img.src = this.canvas.toDataURL();
            }
            
            displayResults(detections) {
                const resultsDiv = document.getElementById('results');
                const detectionsList = document.getElementById('detectionsList');
                
                if (detections.length === 0) {
                    detectionsList.innerHTML = '<p>No objects detected above confidence threshold.</p>';
                } else {
                    detectionsList.innerHTML = detections.map((detection, i) => `
                        <div class="detection-item">
                            <strong>${detection.className}</strong> - 
                            Confidence: ${(detection.score * 100).toFixed(2)}%<br>
                            <small>BBox: [${detection.bbox.map(v => v.toFixed(1)).join(', ')}]</small>
                        </div>
                    `).join('');
                }
                
                resultsDiv.style.display = 'block';
            }
            
            async runInference() {
                try {
                    this.showProgress(0);
                    document.getElementById('runInference').disabled = true;
                    
                    // Load model
                    await this.loadModel();
                    this.showProgress(25);
                    
                    // Preprocess image
                    this.showStatus('Preprocessing image...', 'info');
                    const imageFile = document.getElementById('imageFile').files[0];
                    const imageInfo = await this.preprocessImage(imageFile);
                    this.showProgress(50);
                    
                    // Run inference
                    this.showStatus('Running inference...', 'info');
                    const inputTensor = new ort.Tensor('float32', imageInfo.tensor, [1, 3, this.inputSize, this.inputSize]);
                    const feeds = { [this.session.inputNames[0]]: inputTensor };
                    const outputs = await this.session.run(feeds);
                    this.showProgress(75);
                    
                    // Postprocess results
                    this.showStatus('Processing detections...', 'info');
                    const detections = this.postprocessOutputs(outputs, imageInfo);
                    this.showProgress(90);
                    
                    // Draw and display results
                    this.drawDetections(detections, imageInfo);
                    this.displayResults(detections);
                    this.showProgress(100);
                    
                    this.showStatus(`Inference completed! Found ${detections.length} objects.`, 'success');
                    
                    setTimeout(() => this.showProgress(0), 2000);
                    
                } catch (error) {
                    console.error('Inference error:', error);
                    this.showStatus(`Error: ${error.message}`, 'error');
                    this.showProgress(0);
                } finally {
                    document.getElementById('runInference').disabled = false;
                }
            }
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new YOLOv11Inference();
        });
    </script>
</body>
</html>