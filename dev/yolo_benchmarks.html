<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>ONNX Runtime Benchmark</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="../ext/ort.min.js"></script>
    <style>
        body {
            padding: 2rem;
        }

        .progress {
            height: 25px;
        }

        .spinner-border-sm {
            width: 1rem;
            height: 1rem;
        }

        .results-table {
            font-size: 0.9rem;
        }

        .runtime-info {
            font-family: monospace;
            font-size: 0.85rem;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 class="mb-4">ONNX Runtime Model Benchmark</h1>
        <div class="row">
            <div class="col-md-8">
                <div class="card mb-4">
                    <div class="card-header">
                        <h5>Benchmark Progress</h5>
                    </div>
                    <div class="card-body">
                        <div id="progressContainer" style="display: none;">
                            <div class="progress mb-2">
                                <div id="progressBar" class="progress-bar" style="width: 0%">0%</div>
                            </div>
                            <small id="progressText" class="text-muted">Loading models...</small>
                            <div id="runtimeInfo" class="mt-2 runtime-info"></div>
                        </div>
                        <div id="statusText" class="text-center py-3">
                            <button id="startBtn" class="btn btn-primary btn-lg">Start Benchmark</button>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <h5>Live Benchmark Results</h5>
                    </div>
                    <div class="card-body">
                        <div class="table-responsive">
                            <table class="table table-striped results-table">
                                <thead class="table-dark">
                                    <tr>
                                        <th>Model</th>
                                        <th>Type</th>
                                        <th>Size</th>
                                        <th>WebGPU</th>
                                        <th>WASM</th>
                                        <th>Status</th>
                                    </tr>
                                </thead>
                                <tbody id="resultsBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-md-4">
                <div class="card">
                    <div class="card-header">
                        <h5>System Info</h5>
                    </div>
                    <div class="card-body">
                        <dl class="row mb-0">
                            <dt class="col-sm-5">WebGPU:</dt>
                            <dd class="col-sm-7"><span id="webgpuStatus" class="badge bg-secondary">Checking...</span>
                            </dd>
                            <dt class="col-sm-5">WASM Threads:</dt>
                            <dd class="col-sm-7"><span id="wasmThreads" class="badge bg-secondary">-</span></dd>
                        </dl>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="../utils/DebugConsole.js"></script>
    <script>
        const RUNS_PER_BACKEND = 5;
        let models = [];
        let isRunning = false;

        async function checkWebGPUSupport() {
            if ('gpu' in navigator) {
                try { await navigator.gpu.requestAdapter(); return true; } catch { return false; }
            }
            return false;
        }
        async function loadModels() {
            const res = await fetch('../models/models.json');
            models = await res.json();
        }
        function randTensor(b, c, h, w) {
            return new ort.Tensor('float32',
                Float32Array.from({ length: b * c * h * w }, () => Math.random()),
                [b, c, h, w]
            );
        }
        async function benchmarkModel(modelPath, backend, inputTensor) {
            const sess = await ort.InferenceSession.create(modelPath, {
                executionProviders: [backend],
                logSeverityLevel: 3
            });
            const feeds = { [sess.inputNames[0]]: inputTensor };
            // warm-up
            await sess.run(feeds);
            const times = [];
            for (let i = 0; i < RUNS_PER_BACKEND; i++) {
                const t0 = performance.now();
                await sess.run(feeds);
                times.push(performance.now() - t0);
            }
            return times;
        }
        function stats(arr) {
            if (!arr.length) return { mean: 0, min: 0, max: 0 };
            arr.sort((a, b) => a - b);
            return { mean: arr.reduce((a, b) => a + b) / arr.length, min: arr[0], max: arr[arr.length - 1] };
        }
        function fmt(ms) { return ms < 1000 ? `${ms.toFixed(1)} ms` : `${(ms / 1000).toFixed(2)} s`; }

        // one-time table skeleton
        function initTable() {
            const tbody = document.getElementById('resultsBody');
            tbody.innerHTML = '';
            models.forEach(m => {
                const tr = document.createElement('tr');
                tr.id = `row-${m.name}`;
                tr.innerHTML = `
                    <td>${m.name}</td>
                    <td>${m.type} ${m.version}</td>
                    <td>${m.size}x${m.size}</td>
                    <td id="wg-${m.name}">-</td>
                    <td id="wm-${m.name}">-</td>
                    <td id="st-${m.name}">-</td>`;
                tbody.appendChild(tr);
            });
        }
        function setCell(model, backend, times) {
            const st = stats(times);
            const cellId = backend === 'webgpu' ? `wg-${model}` : `wm-${model}`;
            document.getElementById(cellId).textContent = fmt(st.mean);
        }
        function setStatus(model, txt) {
            document.getElementById(`st-${model}`).innerHTML = txt;
        }

        async function runBenchmark() {
            if (isRunning) return;
            isRunning = true;
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressText').textContent = 'Loading models list...';

            try {
                await loadModels();
                const hasWebGPU = await checkWebGPUSupport();
                const backends = hasWebGPU ? ['webgpu', 'wasm'] : ['wasm'];
                const totalRuns = models.length * backends.length * RUNS_PER_BACKEND;
                let doneRuns = 0;

                initTable();

                for (const m of models) {

                        const input = randTensor(1, 3, m.size, m.size);
                        for (const backend of backends) {
                            try {
                                setStatus(m.name, `<span class="spinner-border spinner-border-sm"></span> ${backend}`);
                                const times = await benchmarkModel(`../models/${m.file}`, backend, input);
                                setCell(m.name, backend, times);
                                doneRuns += RUNS_PER_BACKEND;
                                const pct = (doneRuns / totalRuns) * 100;
                                const st = stats(times);
                                document.getElementById('progressBar').style.width = `${pct}%`;
                                document.getElementById('progressBar').textContent = `${Math.round(pct)}%`;
                                document.getElementById('runtimeInfo').textContent =
                                    `${m.name} @ ${backend}: ${fmt(st.mean)} (±${fmt(st.max - st.min)})`;
                            }
                            catch (error) {
                                console.error(error);
                                setStatus(m.name, 'X');
                            }                        }
                        setStatus(m.name, '✓');
                }
                document.getElementById('progressText').textContent = 'Done';
            } catch (e) {
                document.getElementById('progressText').textContent = 'Error: ' + e.message;
            } finally {
                setTimeout(() => {
                    document.getElementById('progressContainer').style.display = 'none';
                    document.getElementById('startBtn').style.display = 'inline-block';
                    document.getElementById('startBtn').textContent = 'Re-run Benchmark';
                    isRunning = false;
                }, 1500);
            }
        }

        document.getElementById('startBtn').addEventListener('click', runBenchmark);
        checkWebGPUSupport();
        document.getElementById('wasmThreads').textContent = (typeof SharedArrayBuffer !== 'undefined') ? 'Yes' : 'No';
    </script>
</body>

</html>
